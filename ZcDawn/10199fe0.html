<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>图论是什么 | zc'个人博客</title><meta name="author" content="ZcDawn"><meta name="copyright" content="ZcDawn"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="图论是什么 最短路 Dijkstra 12345678910111213141516171819202122232425void dijkstra(int x)&#123;    fill(d.begin(),d.end(),0x3f3f3f3f);    d[x]&#x3D;0;       priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII">
<meta property="og:type" content="article">
<meta property="og:title" content="图论是什么">
<meta property="og:url" content="https://zcdawn.github.io/ZcDawn/10199fe0.html">
<meta property="og:site_name" content="zc&#39;个人博客">
<meta property="og:description" content="图论是什么 最短路 Dijkstra 12345678910111213141516171819202122232425void dijkstra(int x)&#123;    fill(d.begin(),d.end(),0x3f3f3f3f);    d[x]&#x3D;0;       priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zcdawn.github.io/image/888.jpg">
<meta property="article:published_time" content="2025-09-17T14:15:46.000Z">
<meta property="article:modified_time" content="2025-09-17T14:29:59.916Z">
<meta property="article:author" content="ZcDawn">
<meta property="article:tag" content="图论">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="板子">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zcdawn.github.io/image/888.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "图论是什么",
  "url": "https://zcdawn.github.io/ZcDawn/10199fe0.html",
  "image": "https://zcdawn.github.io/image/888.jpg",
  "datePublished": "2025-09-17T14:15:46.000Z",
  "dateModified": "2025-09-17T14:29:59.916Z",
  "author": [
    {
      "@type": "Person",
      "name": "ZcDawn",
      "url": "https://ZcDawn.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zcdawn.github.io/ZcDawn/10199fe0.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":true,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '图论是什么',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.css" /><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/animate.min.css" media="print" onload="this.media='screen'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://img.remit.ee/api/file/BQACAgUAAyEGAASHRsPbAAECGidoygRdvB_lzKfS0U7HH1v6F30wrwAC6hYAAr4MUVYyjYyRGXweSDYE.png);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/image/888.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/s/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/image/chaiquan.png" alt="Logo"><span class="site-name">zc'个人博客</span></a><a class="nav-page-title" href="/"><span class="site-name">图论是什么</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/s/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">图论是什么</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-09-17T14:15:46.000Z" title="发表于 2025-09-17 22:15:46">2025-09-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-17T14:29:59.916Z" title="更新于 2025-09-17 22:29:59">2025-09-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/">板子</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/%E6%9D%BF%E5%AD%90/%E5%9B%BE%E8%AE%BA/">图论</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">18.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>87分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="图论是什么">图论是什么</h1>
<h2 id="最短路">最短路</h2>
<h3 id="dijkstra">Dijkstra</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fill</span>(d.<span class="built_in">begin</span>(),d.<span class="built_in">end</span>(),<span class="number">0x3f3f3f3f</span>);</span><br><span class="line">    d[x]=<span class="number">0</span>;</span><br><span class="line">   </span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,x&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t=q.<span class="built_in">top</span>();q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> u=t.second;</span><br><span class="line">        <span class="keyword">if</span>(vis[u]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[u]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=ed.v;</span><br><span class="line">            <span class="type">int</span> w=ed.w;</span><br><span class="line">            <span class="keyword">if</span>(d[v]&gt;d[u]+w)</span><br><span class="line">            &#123;</span><br><span class="line">                d[v]=d[u]+w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;d[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>复杂度$ O(nlogm) $</li>
<li>不能处理负边权和负环 ### spfa</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt;e[N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="type">int</span> cnt[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[x]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(x);</span><br><span class="line">    st[x]=<span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[u]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[u])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=ed.v,w=ed.w;</span><br><span class="line">            <span class="keyword">if</span>(dist[v]&gt;dist[u]+w)</span><br><span class="line">            &#123;</span><br><span class="line">                dist[v]=dist[u]+w;</span><br><span class="line">                <span class="comment">//cnt[v]=cnt[u]+1;</span></span><br><span class="line">                <span class="comment">//if(cnt[v]&gt;=n) //说明存在负环</span></span><br><span class="line">                <span class="keyword">if</span>(!st[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    st[v]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以处理负边权也可以判负环</li>
<li>最坏<span
class="math inline"><em>O</em>(<em>n</em><em>m</em>)</span></li>
</ul>
<h3 id="floyed">floyed</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//邻接矩阵初始化:i==j d[i][j]=0</span></span><br><span class="line">                  <span class="comment">// i!=j 无边无穷大，有边为边权</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==j) d[i][j]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> d[i][j]=<span class="number">1e9</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyed</span><span class="params">()</span><span class="comment">//全源最短路</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)<span class="comment">//经过k点的最短路</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                d[i][j]=<span class="built_in">min</span>(d[i][j],d[i][k]+d[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bellman-ford">bellman-ford</h3>
<p>可处理有边数限制的最短路 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    dist[x]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)<span class="comment">//最多走k条边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backup,dist,<span class="keyword">sizeof</span> dist);<span class="comment">//每次复制dist数组，用backup数组更新防止串联</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> u=<span class="number">1</span>;u&lt;=n;u++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[u])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> v=ed.v,w=ed.w;</span><br><span class="line">                dist[v]=<span class="built_in">min</span>(dist[v],backup[u]+w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="分层图最短路">分层图最短路</h2>
<h3 id="分层图的一般模型">分层图的一般模型</h3>
<ul>
<li>分层图可以理解为多个平行的图</li>
<li>在一个正常的图上可以进行k次决策，对于每次决策，不影响图的结构，只影响目前的状态或代价。一般将决策前的状态和决策后的状态之间连接一条权值为决策代价的边，表示付出该代价后就可以转换状态。</li>
</ul>
<h3 id="分层图建图方法">分层图建图方法</h3>
<p>根据数据范围选择建图方法 1. 建图时直接建成<span
class="math inline"><em>k</em> + 1</span>层 2. 多开一维记录机会信息</p>
<h4 id="建k1层图">建<span
class="math inline"><em>k</em> + 1</span>层图</h4>
<ul>
<li>建<span
class="math inline"><em>k</em> + 1</span>层图时，对于存在边的两个点，需要多建一条到下一层边权为0的单向边，如果走了这条边就表示用了一次机会。</li>
<li>有<span class="math inline"><em>N</em></span>个点时，<span
class="math inline">(1, <em>n</em>)</span>表示第一层，<span
class="math inline">(1 + <em>n</em>, <em>n</em> + <em>n</em>)</span>代表第二层，<span
class="math inline">(1 + <em>k</em> * <em>n</em>, <em>n</em> + <em>k</em> * <em>n</em>)</span>代表第<span
class="math inline"><em>k</em></span>层。</li>
<li><span class="math inline"><em>k</em></span>层图到<span
class="math inline"><em>n</em></span>点的最短路答案为<span
class="math inline"><em>m</em><em>i</em><em>n</em>(<em>n</em>, 2 * <em>n</em>, 3 * <em>n</em>, ..., <em>k</em> * <em>n</em>)</span>。</li>
</ul>
<h5 id="例-abc395e">例 abc395E</h5>
<h6 id="题意">题意</h6>
<p>有向图边权为1，求<span
class="math inline">1 ∼ <em>n</em></span>的最短路，但可以花费<span
class="math inline"><em>x</em></span>代价反转所有边，可以多次反转。</p>
<h6 id="思路">思路</h6>
<p>建两层图，一层原图，一层反图，对于<span
class="math inline"><em>a</em></span>到<span
class="math inline"><em>b</em></span>的一条有向边，再建一条反转后的<span
class="math inline"><em>b</em></span>到<span
class="math inline"><em>a</em></span>的边，原图和反图上的每个点建代价为<span
class="math inline"><em>x</em></span>的双向边。那么答案为<span
class="math inline"><em>m</em><em>i</em><em>n</em>(<em>d</em><em>i</em><em>s</em><em>t</em>[<em>n</em>], <em>d</em><em>i</em><em>s</em><em>t</em>[2 * <em>n</em>])</span>。</p>
<h6 id="代码">代码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    ll v,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt;e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> n,m,x;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        e[a].<span class="built_in">pb</span>(&#123;b,<span class="number">1</span>&#125;);</span><br><span class="line">        e[b+n].<span class="built_in">pb</span>(&#123;a+n,<span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        e[i].<span class="built_in">pb</span>(&#123;i+n,x&#125;);</span><br><span class="line">        e[i+n].<span class="built_in">pb</span>(&#123;i,x&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">dist</span>(<span class="number">2</span>*n<span class="number">+10</span>,<span class="number">1e18</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> dij=[&amp;](<span class="type">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt;<span class="built_in">vis</span>(<span class="number">2</span>*n<span class="number">+1</span>);</span><br><span class="line">        </span><br><span class="line">        priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,x&#125;);</span><br><span class="line">        dist[x]=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> [cost,cur]=q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(vis[cur]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[cur]=<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:e[cur])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(dist[v]&gt;cost+w)</span><br><span class="line">                &#123;</span><br><span class="line">                    dist[v]=cost+w;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;dist[v],v&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">dij</span>(<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;<span class="built_in">min</span>(dist[n],dist[<span class="number">2</span>*n])&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多开一维记录机会信息">多开一维记录机会信息</h4>
<ul>
<li>把dist和vis数组以及优先队列多开一维记录<span
class="math inline"><em>k</em></span>次机会的信息。</li>
<li>最短路算法更新dist数组时，对于使用和不使用机会分别更新</li>
</ul>
<h4 id="例题-洛谷p4568-飞行路线">例题 洛谷P4568 飞行路线</h4>
<h5 id="题意-1">题意</h5>
<p>Alice 和 Bob
现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在
<span class="math inline"><em>n</em></span>
个城市设有业务，设这些城市分别标记为 <span class="math inline">0</span>
到 <span class="math inline"><em>n</em> − 1</span>，一共有 <span
class="math inline"><em>m</em></span>
种航线，每种航线连接两个城市，并且航线有一定的价格。</p>
<p>Alice 和 Bob
现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多
<span class="math inline"><em>k</em></span> 种航线上搭乘飞机。那么 Alice
和 Bob 这次出行最少花费多少？</p>
<h5 id="思路-1">思路</h5>
<p>多开一维记录免费次数，对于每个点，分别更新使用和不使用免费机会的代价</p>
<h5 id="代码-1">代码</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;edge&gt;e[N];</span><br><span class="line"><span class="type">int</span> dist[N][<span class="number">11</span>];</span><br><span class="line"><span class="type">int</span> vis[N][<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,k,s,t;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        e[a].<span class="built_in">pb</span>(&#123;b,c&#125;);</span><br><span class="line">        e[b].<span class="built_in">pb</span>(&#123;a,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(dist,inf,<span class="keyword">sizeof</span> dist);</span><br><span class="line">    priority_queue&lt;PIII,vector&lt;PIII&gt;,greater&lt;PIII&gt;&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s,k&#125;);</span><br><span class="line">    dist[s][k]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [d,cur,times]=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">//if(cur==t) &#123;cout&lt;&lt;d&lt;&lt;endl;return;&#125;</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;d&lt;&lt;&quot; &quot;&lt;&lt;cur&lt;&lt;&quot; &quot;&lt;&lt;times&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">if</span>(vis[cur][times]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[cur][times]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用一次免费次数扩点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[cur])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> v=ed.v,w=ed.w;</span><br><span class="line">            <span class="keyword">if</span>(!vis[v][times<span class="number">-1</span>] &amp;&amp; d&lt;dist[v][times<span class="number">-1</span>] &amp;&amp; times)</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;d,v,times<span class="number">-1</span>&#125;);</span><br><span class="line">                dist[v][times<span class="number">-1</span>]=d;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//不用免费次数</span></span><br><span class="line">            <span class="keyword">if</span>(!vis[v][times] &amp;&amp; d+w&lt;dist[v][times])</span><br><span class="line">            &#123;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;d+w,v,times&#125;);</span><br><span class="line">                dist[v][times]=d+w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=k;i++) ans=<span class="built_in">min</span>(ans,dist[t][i]);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="例题-div3-974-e">例题 div3 974 E</h4>
<h5 id="题意-2">题意</h5>
<p><span class="math inline"><em>n</em></span>个点，其中<span
class="math inline"><em>h</em></span>个点有马，到达这些点上马之后速度可由2变为1，两人分别从1号点和n号点出发，并在一点相遇，求两人相遇所花的最短时间</p>
<h5 id="思路-2">思路</h5>
<p>建反边，多开一维记录当前是否有马，分别从1号点和n号点跑dij，枚举相遇的点，从四种状态中取最小即可</p>
<h5 id="代码-2">代码</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;edge&gt;e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m,h;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;h;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) e[i].<span class="built_in">clear</span>();</span><br><span class="line">    </span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">hourse</span>(n<span class="number">+1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=h;i++) &#123;cin&gt;&gt;x;hourse[x]=<span class="number">1</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        e[a].<span class="built_in">pb</span>(&#123;b,c&#125;);</span><br><span class="line">        e[b].<span class="built_in">pb</span>(&#123;a,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt;<span class="built_in">dist1</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;ll&gt;(<span class="number">2</span>,<span class="number">1e18</span>));</span><br><span class="line">    <span class="keyword">auto</span> dist2=dist1;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;PIII,vector&lt;PIII&gt;,greater&lt;PIII&gt;&gt;q;<span class="comment">//到达i点且是否有马</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> work=[&amp;](vector&lt;vector&lt;ll&gt;&gt;&amp;dist)</span><br><span class="line">    &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">vis</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">auto</span> [cost,cur,st]=q.<span class="built_in">top</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(vis[cur][st]) <span class="keyword">continue</span>;</span><br><span class="line">            vis[cur][st]=<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[cur])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> w=ed.w,v=ed.v;</span><br><span class="line">                <span class="keyword">if</span>(st) <span class="comment">//有马</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>( !vis[v][<span class="number">1</span>] &amp;&amp; cost+w/<span class="number">2</span>&lt;dist[v][<span class="number">1</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dist[v][<span class="number">1</span>]=cost+w/<span class="number">2</span>;</span><br><span class="line">                        q.<span class="built_in">push</span>(&#123;dist[v][<span class="number">1</span>],v,st&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span><span class="comment">//没马</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(!vis[v][<span class="number">0</span>] &amp;&amp; cost+w&lt;dist[v][<span class="number">0</span>])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dist[v][<span class="number">0</span>]=cost+w;</span><br><span class="line">                        q.<span class="built_in">push</span>(&#123;dist[v][<span class="number">0</span>],v,st|hourse[v]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>,hourse[<span class="number">1</span>]&#125;);</span><br><span class="line">    dist1[<span class="number">1</span>][hourse[<span class="number">1</span>]]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">work</span>(dist1);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    q=priority_queue&lt;PIII,vector&lt;PIII&gt;,greater&lt;PIII&gt;&gt;();</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,n,hourse[n]&#125;);</span><br><span class="line">    dist2[n][hourse[n]]=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">work</span>(dist2);</span><br><span class="line">    </span><br><span class="line">    ll ans=<span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll res=<span class="built_in">min</span>(&#123;<span class="built_in">max</span>(dist1[i][<span class="number">0</span>],dist2[i][<span class="number">0</span>]),<span class="built_in">max</span>(dist1[i][<span class="number">0</span>],dist2[i][<span class="number">1</span>]),<span class="built_in">max</span>(dist1[i][<span class="number">1</span>],dist2[i][<span class="number">0</span>]),<span class="built_in">max</span>(dist1[i][<span class="number">1</span>],dist2[i][<span class="number">1</span>])&#125;);</span><br><span class="line">        ans=<span class="built_in">min</span>(ans,res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">1e18</span>) cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线段树优化建图">线段树优化建图</h2>
<h3 id="trik">trik</h3>
<p>线段树优化建图，顾名思义利用线段树建图优化时间复杂度，常用于以下操作
- 区间向区间连边 - 区间向点连边 - 点向区间连边</p>
<p>若使用暴力连边，时间复杂度是<span
class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span>，但是如果我们基于线段树区间分解的思想，将一个区间分解为最多<span
class="math inline"><em>l</em><em>o</em><em>g</em><em>n</em></span>个区间再去连边，时间复杂度就可以降为<span
class="math inline"><em>O</em>(<em>n</em><em>l</em><em>o</em><em>g</em><em>n</em>)</span></p>
<p>例如对于8个点，我们现在要将点2向区间<span
class="math inline">[3, 7]</span>连边，那么我们可以将2分别连向<span
class="math inline">[3, 4], [5, 6], [7, 7]</span>,具体到线段树上就是向这三个区间对应的编号连边。因为每个区间都可以访问到其子区间的点，所以我们应该将所有区间对其子区间建代价为0的边。
对于区间向点连边，我们反过来建边，即所要操作的所有区间向点连边，同样我们要把子区间向父区间连边
但是若两种操作同时存在时，只开一颗线段树明显会出现错误，因为每个区间都可以0代价的访问到其他区间，由此我们引入出树和入树的概念</p>
<ul>
<li>出树： 只连自上向下的边，即父向子连边
负责将实际起点或起点区间聚合到高层状态</li>
<li>入树： 只连自下向上的边，即子向父连边 将终点区间分发到具体的点
因此我们在外部连边时都是入树指向出树
同时我们还要将出树与入数的对应叶子节点连代价为0的边，代表其能相互转换</li>
</ul>
<p>所以对于上面的操作我们可以这样实现 1.
点向区间连边：将入树的对应节点向出树的对应区间节点连边 2.
区间向点连边：将入树的对应区间节点向出树的对应节点连边 3.
区间向区间连边：建立一个虚点，分别向两个区间连边，一条边权为w，一条边权为0，由于是双向边，需要建立
- 出树 <span class="math inline">→</span> 虚点 <span
class="math inline">→</span> 入树 - 入树 <span
class="math inline">→</span> 虚点 <span class="math inline">→</span>
出树</p>
<h3 id="例题">例题</h3>
<h4 id="cf786b">cf786B</h4>
<h5 id="题意-3">题意</h5>
<p><span class="math inline"><em>n</em></span>个点<span
class="math inline"><em>m</em></span>次操作，每次操作为下面三种之一,求给定点到其他点的最短路
1. 点向点连边 2. 点向区间连边 3. 区间向点连边 <span
class="math inline">1 ≤ <em>n</em>, <em>m</em> ≤ 10<sup>5</sup></span></p>
<h5 id="思路-3">思路</h5>
<p>毫无疑问的板子题，开两棵线段树对应连边即可，对于点向点连边我们将出树和入树的叶子节点连边即可，这里我们选择用偏移量代表入树，需要注意开ll，一般线段树的大小为<span
class="math inline">4 * <em>N</em></span>，开两颗我们需要<span
class="math inline">8 * <em>N</em></span>的大小，同时偏移量取<span
class="math inline">4 * <em>N</em></span>即可，需要注意一定是入树向出树连边，需要额外开一个数组记录叶子节点在线段树上所对应的编号</p>
<h5 id="代码-3">代码</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1e9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1e18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(a) a.begin()+1,a.end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all0(a) a.begin(),a.end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(a) (a&amp;-a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> yes cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> no cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,ll&gt;PII;</span><br><span class="line"><span class="keyword">typedef</span> array&lt;<span class="type">int</span>,3&gt;PIII;</span><br><span class="line"><span class="function">mt19937_64 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span><span class="number">+5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> K=<span class="number">5e5</span>;<span class="comment">//入树偏移</span></span><br><span class="line"></span><br><span class="line">ll tr[N];</span><br><span class="line">ll leaf[N];<span class="comment">//叶子节点编号</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    ll v,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt;e[N];</span><br><span class="line"></span><br><span class="line">ll dis[N];</span><br><span class="line">ll vis[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r) </span><br><span class="line">    &#123;</span><br><span class="line">        leaf[l]=p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    e[p].<span class="built_in">pb</span>(&#123;lc,<span class="number">0</span>&#125;);</span><br><span class="line">    e[p].<span class="built_in">pb</span>(&#123;rc,<span class="number">0</span>&#125;);</span><br><span class="line">    e[(lc)+K].<span class="built_in">pb</span>(&#123;p+K,<span class="number">0</span>&#125;);</span><br><span class="line">    e[(rc)+K].<span class="built_in">pb</span>(&#123;p+K,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="built_in">build</span>(lc,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rc,mid<span class="number">+1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> v,<span class="type">int</span> ul,<span class="type">int</span> ur,<span class="type">int</span> w,<span class="type">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ul&lt;=l &amp;&amp; ur&gt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">2</span>) e[leaf[v]+K].<span class="built_in">pb</span>(&#123;p,w&#125;);</span><br><span class="line">        <span class="keyword">else</span> e[p+K].<span class="built_in">pb</span>(&#123;leaf[v],w&#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ul&lt;=mid) <span class="built_in">update</span>(lc,l,mid,v,ul,ur,w,op);</span><br><span class="line">    <span class="keyword">if</span>(ur&gt;mid) <span class="built_in">update</span>(rc,mid<span class="number">+1</span>,r,v,ul,ur,w,op);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n,m,s;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        e[leaf[i]].<span class="built_in">pb</span>(&#123;leaf[i]+K,<span class="number">0</span>&#125;);</span><br><span class="line">        e[leaf[i]+K].<span class="built_in">pb</span>(&#123;leaf[i],<span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op;cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ll u,v,w;cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">            e[leaf[u]+K].<span class="built_in">pb</span>(&#123;leaf[v],w&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ll v,l,r,w;</span><br><span class="line">            cin&gt;&gt;v&gt;&gt;l&gt;&gt;r&gt;&gt;w;</span><br><span class="line">            <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,v,l,r,w,op);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,leaf[s]&#125;);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cost,cur]=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(vis[cur]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[cur]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:e[cur])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cost+w&lt;dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=cost+w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dis[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dis[leaf[i]]==<span class="number">0x3f3f3f3f3f3f3f3fll</span>) cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> cout&lt;&lt;dis[leaf[i]]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h4 id="p5025炸弹">P5025炸弹</h4>
<h5 id="题意-4">题意</h5>
<p>在一条直线上有 <span class="math inline"><em>n</em></span>
个炸弹，每个炸弹的坐标是 $ x_i $，爆炸半径是 $ r_i
$，当一个炸弹爆炸时，如果另一个炸弹所在位置 <span
class="math inline"><em>x</em><sub><em>j</em></sub></span> 满足： <span
class="math inline">|<em>x</em><sub><em>j</em></sub> − <em>x</em><sub><em>i</em></sub>| ≤ <em>r</em><sub><em>i</em></sub></span>
，那么，该炸弹也会被引爆。<br />
现在，请你帮忙计算一下，先把第 <span
class="math inline"><em>i</em></span>
个炸弹引爆，将引爆多少个炸弹呢？</p>
<p>答案对 <span class="math inline">10<sup>9</sup> + 7</span> 取模</p>
<p>第一行，一个数字 <span class="math inline"><em>n</em></span>
，表示炸弹个数。 第 <span class="math inline">2 ∼ <em>n</em> + 1</span>
行，每行两个整数，表示 <span
class="math inline"><em>x</em><sub><em>i</em></sub></span>，<span
class="math inline"><em>r</em><sub><em>i</em></sub></span>，保证 <span
class="math inline"><em>x</em><sub><em>i</em></sub></span>
严格递增。</p>
<p>一个数字，表示 <span class="math inline">$\sum \limits_{i=1}^n
i\times$</span> 炸弹 <span class="math inline"><em>i</em></span>
能引爆的炸弹个数。</p>
<p>对于 <span class="math inline">20%</span> 的数据： <span
class="math inline"><em>n</em> ≤ 100</span>。</p>
<p>对于 <span class="math inline">50%</span> 的数据： <span
class="math inline"><em>n</em> ≤ 1000</span>。</p>
<p>对于 <span class="math inline">80%</span> 的数据： <span
class="math inline"><em>n</em> ≤ 100000</span>。</p>
<p>对于 <span class="math inline">100%</span> 的数据： <span
class="math inline">1 ≤ <em>n</em> ≤ 500000</span>，<span
class="math inline">−10<sup>18</sup> ≤ <em>x</em><sub><em>i</em></sub> ≤ 10<sup>18</sup></span>，<span
class="math inline">0 ≤ <em>r</em><sub><em>i</em></sub> ≤ 2 × 10<sup>18</sup></span>。</p>
<h5 id="思路-4">思路</h5>
<p>很容易能想到可以将每个炸弹向在其引爆范围的其他炸弹建边，每个点所能到达点的个数就是答案，但这样做是<span
class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span>的，无疑不能接受，那么我们就可以用线段树优化建图，建完图之后为了方便统计答案，我们可以用tarjan缩点，缩点过程中我们记录每个连通块内的点所能影响到的最左侧和最右侧点，这样对于一个点，其贡献就是其编号乘以其所在连通块中最右侧的点减去最左侧的点(直接使用连通块大小会重复计算)，但是这样还不够，缩点完之后还会有外部的点可以访问到连通块的情况，所以我们缩点之后应该再跑一次dfs更新每个点所能访问到的最左侧点和最右侧点，最后计算答案即可</p>
<h5 id="代码-4">代码</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1e9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1e18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(a) a.begin()+1,a.end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all0(a) a.begin(),a.end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(a) (a&amp;-a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> yes cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> no cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">typedef</span> array&lt;<span class="type">int</span>,3&gt;PIII;</span><br><span class="line"><span class="function">mt19937_64 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod=<span class="number">1e9</span><span class="number">+7</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    ll l,r;</span><br><span class="line">&#125;tr[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">ll Left[N*<span class="number">4</span>];</span><br><span class="line">ll Right[N*<span class="number">4</span>];<span class="comment">//每个连通块能影响到的最远两端点</span></span><br><span class="line">vector&lt;ll&gt;e[N*<span class="number">4</span>];</span><br><span class="line">vector&lt;ll&gt;e1[N*<span class="number">4</span>];</span><br><span class="line">ll leaf[N];</span><br><span class="line">ll id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ll dfn[N*<span class="number">4</span>],low[N*<span class="number">4</span>],tot;</span><br><span class="line">ll stk[N*<span class="number">4</span>],instk[N*<span class="number">4</span>],top;</span><br><span class="line">ll scc[N*<span class="number">4</span>],siz[N*<span class="number">4</span>],cnt;</span><br><span class="line">ll vis[N*<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(ll p,ll l,ll r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    id=<span class="built_in">max</span>(id,p);</span><br><span class="line">    tr[p]=&#123;l,r&#125;;</span><br><span class="line">    <span class="keyword">if</span>(l==r) &#123;leaf[l]=p;<span class="keyword">return</span>;&#125;</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    e[p].<span class="built_in">pb</span>(lc);</span><br><span class="line">    e[p].<span class="built_in">pb</span>(rc);</span><br><span class="line">    <span class="built_in">build</span>(lc,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rc,mid<span class="number">+1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ll p,ll l,ll r,ll v,ll ul,ll ur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ul&lt;=l &amp;&amp; ur&gt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        e[v].<span class="built_in">pb</span>(p);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ul&lt;=mid) <span class="built_in">update</span>(lc,l,mid,v,ul,ur);</span><br><span class="line">    <span class="keyword">if</span>(ur&gt;mid) <span class="built_in">update</span>(rc,mid<span class="number">+1</span>,r,v,ul,ur);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(ll x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++tot;</span><br><span class="line">    stk[++top]=x;</span><br><span class="line">    instk[x]=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[ed])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(ed);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[ed]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instk[ed]) low[x]=<span class="built_in">min</span>(low[x],dfn[ed]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x]==low[x])</span><br><span class="line">    &#123;</span><br><span class="line">        ll y;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            y=stk[top--];</span><br><span class="line">            instk[y]=<span class="number">0</span>;</span><br><span class="line">            scc[y]=cnt;</span><br><span class="line">            ++siz[cnt];</span><br><span class="line">            Left[cnt]=<span class="built_in">min</span>(Left[cnt],tr[y].l);</span><br><span class="line">            Right[cnt]=<span class="built_in">max</span>(Right[cnt],tr[y].r);</span><br><span class="line">            <span class="comment">//cout&lt;&lt;cnt&lt;&lt;&quot; &quot;&lt;&lt;Left[cnt]&lt;&lt;&quot; &quot;&lt;&lt;Right[cnt]&lt;&lt;endl;</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(y!=x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(ll u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e1[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[ed])</span><br><span class="line">        &#123;</span><br><span class="line">            Left[u]=<span class="built_in">min</span>(Left[u],Left[ed]);</span><br><span class="line">            Right[u]=<span class="built_in">max</span>(Right[u],Right[ed]);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(ed);</span><br><span class="line">        Left[u]=<span class="built_in">min</span>(Left[u],Left[ed]);</span><br><span class="line">        Right[u]=<span class="built_in">max</span>(Right[u],Right[ed]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll n;cin&gt;&gt;n;</span><br><span class="line">    vector&lt;ll&gt;<span class="built_in">x</span>(n<span class="number">+1</span>),<span class="built_in">r</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;x[i]&gt;&gt;r[i];</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(Left,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> Left);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!r[i]) <span class="keyword">continue</span>;</span><br><span class="line">        ll L=<span class="built_in">lower_bound</span>(<span class="built_in">all</span>(x),x[i]-r[i])-x.<span class="built_in">begin</span>();</span><br><span class="line">        ll R=<span class="built_in">upper_bound</span>(<span class="built_in">all</span>(x),x[i]+r[i])-x.<span class="built_in">begin</span>();</span><br><span class="line">        R--;</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,leaf[i],L,R);</span><br><span class="line">        tr[leaf[i]]=&#123;L,R&#125;;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=id;i++) <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=id;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(scc[ed]!=scc[i])</span><br><span class="line">            &#123;</span><br><span class="line">                e1[scc[i]].<span class="built_in">pb</span>(scc[ed]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//for(int i=1;i&lt;=cnt;i++) cout&lt;&lt;Left[i]&lt;&lt;&quot; &quot;&lt;&lt;Right[i]&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=id;i++) <span class="keyword">if</span>(!vis[i]) <span class="built_in">dfs</span>(i);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">//	for(int i=1;i&lt;=cnt;i++) cout&lt;&lt;Left[i]&lt;&lt;&quot; &quot;&lt;&lt;Right[i]&lt;&lt;endl;</span></span><br><span class="line">    </span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=(ans+i*(Right[scc[leaf[i]]]-Left[scc[leaf[i]]]<span class="number">+1</span>)%mod)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h4 id="p6348-journeys">P6348 Journeys</h4>
<h5 id="题意-5">题意</h5>
<p>一个星球上有 <span class="math inline"><em>n</em></span>
个国家和许多双向道路，国家用 <span
class="math inline">1 ∼ <em>n</em></span> 编号。</p>
<p>但是道路实在太多了，不能用通常的方法表示。于是我们以如下方式表示道路：<span
class="math inline">(<em>a</em>, <em>b</em>), (<em>c</em>, <em>d</em>)</span>
表示，对于任意两个国家 <span
class="math inline"><em>x</em>, <em>y</em></span>，如果 <span
class="math inline"><em>a</em> ≤ <em>x</em> ≤ <em>b</em>, <em>c</em> ≤ <em>y</em> ≤ <em>d</em></span>，那么在
<span class="math inline"><em>x</em>, <em>y</em></span>
之间有一条道路。</p>
<p>首都位于 <span class="math inline"><em>P</em></span> 号国家。你想知道
<span class="math inline"><em>P</em></span>
号国家到任意一个国家最少需要经过几条道路。保证 <span
class="math inline"><em>P</em></span> 号国家能到任意一个国家。</p>
<p>第一行三个整数 <span
class="math inline"><em>n</em>, <em>m</em>, <em>P</em></span>。 之后
<span class="math inline"><em>m</em></span> 行，每行 <span
class="math inline">4</span> 个整数 <span
class="math inline"><em>a</em>, <em>b</em>, <em>c</em>, <em>d</em></span>。</p>
<p><span class="math inline"><em>n</em></span> 行，第 <span
class="math inline"><em>i</em></span> 行表示 <span
class="math inline"><em>P</em></span> 号国家到第 <span
class="math inline"><em>i</em></span> 个国家最少需要经过几条路。</p>
<p>对于所有测试点，保证 <span
class="math inline">1 ≤ <em>n</em> ≤ 5 × 10<sup>5</sup></span>，<span
class="math inline">1 ≤ <em>m</em> ≤ 10<sup>5</sup></span>，<span
class="math inline">1 ≤ <em>a</em> ≤ <em>b</em> ≤ <em>n</em></span>，<span
class="math inline">1 ≤ <em>c</em> ≤ <em>d</em> ≤ <em>n</em></span>。</p>
<h5 id="思路-5">思路</h5>
<p>区间向区间连边，如果直接两个区间连的话是<span
class="math inline"><em>O</em>((<em>l</em><em>o</em><em>g</em><em>n</em>)<sup>2</sup>)</span>，可以对于每个区间开一个虚点，这样将两个区间分别连向这个虚点即可降到<span
class="math inline"><em>O</em>(<em>l</em><em>o</em><em>g</em><em>n</em>)</span>,由于是双向边所以需要建立两次，即
- 出树 <span class="math inline">→</span> 虚点 <span
class="math inline">→</span> 入树 - 入树 <span
class="math inline">→</span> 虚点 <span class="math inline">→</span>
出树 由于出树和入树叶子节点互相连边，所以哪个当起点和终点都无所谓</p>
<h5 id="代码-5">代码</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1e9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1e18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(a) a.begin()+1,a.end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all0(a) a.begin(),a.end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(a) (a&amp;-a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> yes cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> no cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">typedef</span> array&lt;<span class="type">int</span>,3&gt;PIII;</span><br><span class="line"><span class="function">mt19937_64 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> leaf[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;edge&gt;e[N&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> n,m,p;</span><br><span class="line"><span class="type">int</span> tot;<span class="comment">//虚点偏移量</span></span><br><span class="line"><span class="type">int</span> dis[N&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> vis[N&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        leaf[l]=p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e[p].<span class="built_in">pb</span>(&#123;lc,<span class="number">0</span>&#125;);</span><br><span class="line">    e[p].<span class="built_in">pb</span>(&#123;rc,<span class="number">0</span>&#125;);</span><br><span class="line">    e[(lc)+n*<span class="number">4</span>].<span class="built_in">pb</span>(&#123;p+n*<span class="number">4</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    e[(rc)+n*<span class="number">4</span>].<span class="built_in">pb</span>(&#123;p+n*<span class="number">4</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rc,mid<span class="number">+1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//0:入树向虚点连，1：虚点向出树连</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ul,<span class="type">int</span> ur,<span class="type">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ul&lt;=l &amp;&amp; ur&gt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!op) e[p+n*<span class="number">4</span>].<span class="built_in">pb</span>(&#123;n*<span class="number">8</span>+tot,<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">else</span> e[n*<span class="number">8</span>+tot].<span class="built_in">pb</span>(&#123;p,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ul&lt;=mid) <span class="built_in">update</span>(lc,l,mid,ul,ur,op);</span><br><span class="line">    <span class="keyword">if</span>(ur&gt;mid) <span class="built_in">update</span>(rc,mid<span class="number">+1</span>,r,ul,ur,op);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;p;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        e[leaf[i]<span class="number">+4</span>*n].<span class="built_in">pb</span>(&#123;leaf[i],<span class="number">0</span>&#125;);</span><br><span class="line">        e[leaf[i]].<span class="built_in">pb</span>(&#123;leaf[i]<span class="number">+4</span>*n,<span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c,d;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">        tot++;</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,a,b,<span class="number">0</span>);<span class="comment">//出树</span></span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,c,d,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        tot++;</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,a,b,<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,c,d,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,leaf[p]&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[leaf[p]]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cost,cur]=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(vis[cur]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[cur]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:e[cur])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cost+w&lt;dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=cost+w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dis[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;dis[leaf[i]]&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h4
id="atcoder-nikkei-programming-contest-2019-2-d---shortest-path-on-a-line">atcoder
NIKKEI Programming Contest 2019-2 D - Shortest Path on a Line</h4>
<h5 id="题意-6">题意</h5>
<p>给定<span class="math inline"><em>n</em></span>个点，<span
class="math inline"><em>m</em></span>行形如<span
class="math inline"><em>a</em>, <em>b</em>, <em>c</em></span>的建边方式，代表<span
class="math inline">[<em>a</em>, <em>b</em>]</span>区间内的点都互相建立一条边权为<span
class="math inline"><em>c</em></span>的点，求1到n的最短路径</p>
<h5 id="思路-6">思路</h5>
<p>即区间向区间连边，只不过是这个区间向自己连边，那么我们在加边时只加一次即可</p>
<h5 id="代码-6">代码</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 1e9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 1e18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lc p&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rc p&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> endl <span class="string">&#x27;\n&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all(a) a.begin()+1,a.end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> all0(a) a.begin(),a.end()</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> lowbit(a) (a&amp;-a)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fi first</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> se second</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pb push_back</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> yes cout&lt;&lt;<span class="string">&quot;YES&quot;</span>&lt;&lt;endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> no cout&lt;&lt;<span class="string">&quot;NO&quot;</span>&lt;&lt;endl</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps=<span class="number">1e-6</span>;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;ll,<span class="type">int</span>&gt;PII;</span><br><span class="line"><span class="keyword">typedef</span> array&lt;<span class="type">int</span>,3&gt;PIII;</span><br><span class="line"><span class="function">mt19937_64 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> leaf[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    ll v,w;</span><br><span class="line">&#125;;</span><br><span class="line">ll dis[N&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> vis[N&lt;&lt;<span class="number">4</span>];</span><br><span class="line">vector&lt;edge&gt;e[N&lt;&lt;<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">    &#123;</span><br><span class="line">        leaf[l]=p;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    e[p].<span class="built_in">pb</span>(&#123;lc,<span class="number">0</span>&#125;);</span><br><span class="line">    e[p].<span class="built_in">pb</span>(&#123;rc,<span class="number">0</span>&#125;);</span><br><span class="line">    e[(lc)<span class="number">+4</span>*n].<span class="built_in">pb</span>(&#123;p<span class="number">+4</span>*n,<span class="number">0</span>&#125;);</span><br><span class="line">    e[(rc)<span class="number">+4</span>*n].<span class="built_in">pb</span>(&#123;p<span class="number">+4</span>*n,<span class="number">0</span>&#125;);</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(lc,l,mid);</span><br><span class="line">    <span class="built_in">build</span>(rc,mid<span class="number">+1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> ul,<span class="type">int</span> ur,<span class="type">int</span> w,<span class="type">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(ul&lt;=l &amp;&amp; ur&gt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!op) e[p<span class="number">+4</span>*n].<span class="built_in">pb</span>(&#123;<span class="number">8</span>*n+tot,w&#125;);</span><br><span class="line">        <span class="keyword">else</span> e[<span class="number">8</span>*n+tot].<span class="built_in">pb</span>(&#123;p,<span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ul&lt;=mid) <span class="built_in">update</span>(lc,l,mid,ul,ur,w,op);</span><br><span class="line">    <span class="keyword">if</span>(ur&gt;mid) <span class="built_in">update</span>(rc,mid<span class="number">+1</span>,r,ul,ur,w,op);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        e[leaf[i]].<span class="built_in">pb</span>(&#123;leaf[i]<span class="number">+4</span>*n,<span class="number">0</span>&#125;);</span><br><span class="line">        e[leaf[i]<span class="number">+4</span>*n].<span class="built_in">pb</span>(&#123;leaf[i],<span class="number">0</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        </span><br><span class="line">        tot++;</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,a,b,c,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">update</span>(<span class="number">1</span>,<span class="number">1</span>,n,a,b,c,<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// tot++;</span></span><br><span class="line">        <span class="comment">// update(1,1,n,a,b,c,1);</span></span><br><span class="line">        <span class="comment">// update(1,1,n,a,b,c,0);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,leaf[<span class="number">1</span>]<span class="number">+4</span>*n&#125;);</span><br><span class="line">    <span class="built_in">memset</span>(dis,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dis);</span><br><span class="line">    dis[leaf[<span class="number">1</span>]<span class="number">+4</span>*n]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cost,cur]=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(vis[cur]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[cur]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:e[cur])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cost+w&lt;dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=cost+w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dis[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(dis[leaf[n]]==<span class="number">0x3f3f3f3f3f3f3f3f</span>?<span class="number">-1</span>:dis[leaf[n]])&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="拓扑排序">拓扑排序</h2>
<p>步骤：找到入度为0的点，删掉该点和其所有出边，不断重复该操作，若所有点都能被删完，则为有拓扑排序，否则无拓扑排序
-
无向图也可以通过拓扑排序找环，入队条件改为度为1即可，最终没有入队过的点即为环上的点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[t])</span><br><span class="line">        &#123;</span><br><span class="line">            d[ed]--;</span><br><span class="line">            <span class="keyword">if</span>(d[ed]==<span class="number">0</span>) &#123;cout&lt;&lt;ed&lt;&lt;<span class="string">&quot; &quot;</span>;q.<span class="built_in">push</span>(ed);&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(cin&gt;&gt;x,x)</span><br><span class="line">        &#123;</span><br><span class="line">            e[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">            d[x]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树">最小生成树</h2>
<h3 id="prime">Prime</h3>
<p>和dij十分相似，区别为dist数组的含义
dij中dist的含义为该点到其他点中最小距离
prime中dist的含义为该点到源点的最短距离 步骤： 1.
建立空集合a，选择一个出发点加入a 2.
遍历与a中的点相邻的边，找到最短的边但不构成环 3.
将2中得到的边的终点加入a 4. 重复2，3步直到所有的结点都加入集合a -
时间复杂度<span
class="math inline"><em>O</em>(<em>n</em><sup>2</sup>)</span> -
适合边多的图 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt;e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        e[a].<span class="built_in">pb</span>(&#123;b,c&#125;);</span><br><span class="line">        e[b].<span class="built_in">pb</span>(&#123;a,c&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt;&gt;q;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">dis</span>(n<span class="number">+1</span>,inf);<span class="comment">//该点到邻点的最短距离</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">vis</span>(n<span class="number">+1</span>);</span><br><span class="line">    <span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    dis[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [cost,cur]=q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(vis[cur]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[cur]=<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        ans+=dis[cur];</span><br><span class="line">        cnt++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [v,w]:e[cur])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(w&lt;dis[v])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v]=w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dis[v],v&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt==n) cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### Kruscal</p>
<p>利用并查集，将边权从小到大排序，依次枚举每条边能否加入，如果加入该条边之后构成了环那么就舍弃该边
- 时间复杂度<span
class="math inline"><em>o</em>(<em>m</em><em>l</em><em>o</em><em>g</em><em>m</em>)</span>
- 适合点多边少</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="comment">//typedef pair&lt;int,int&gt;PII;</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> u,v,w;<span class="comment">//第i条边的起点终点边权</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> edge &amp;t) <span class="type">const</span><span class="comment">//重载小于号，升序排</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> p[N];<span class="comment">//父节点数组</span></span><br><span class="line"><span class="type">int</span> ans,cnt;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//并查集</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x) p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(e<span class="number">+1</span>,e+m<span class="number">+1</span>);<span class="comment">//按边权从小到大排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="built_in">find</span>(e[i].u);<span class="comment">//起点的父节点</span></span><br><span class="line">        <span class="type">int</span> y=<span class="built_in">find</span>(e[i].v);<span class="comment">//终点的父节点</span></span><br><span class="line">        <span class="keyword">if</span>(x!=y)<span class="comment">//若二者父节点不同，说明可以选为最小生成树的边</span></span><br><span class="line">        &#123;</span><br><span class="line">            p[x]=y;<span class="comment">//合并二者</span></span><br><span class="line">            ans+=e[i].w;<span class="comment">//累加最小生成树边权</span></span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        e[i]=&#123;a,b,c&#125;;<span class="comment">//建图</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) p[i]=i;<span class="comment">//初始化父节点</span></span><br><span class="line">    <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="keyword">if</span>(cnt!=n<span class="number">-1</span>) cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>;<span class="comment">//边数等于n-1说明有最小生成树</span></span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="瓶颈生成树">瓶颈生成树</h3>
<p>树上最大边权值在图的所有生成树中最小的生成树叫做瓶颈生成树
说人话:生成树的多种方案中，选择边权最大的边最小的方案，叫做瓶颈生成树</p>
<p>性质:最小生成树一定是瓶颈生成树，但瓶颈生成树未必是最小生成树
例题:信奥一本通1392，洛谷p2330，求瓶颈生成树直接求最小生成树即可</p>
<h2 id="二分图">二分图</h2>
<p>定义：无向图的n个节点可以分为a,b两个不相交的非空集合，并且同一集合的点之间没有边相连，则该图为二分图
### 染色法判二分图</p>
<p>判断是否存在奇环，存在则不为二分图</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        e[a].<span class="built_in">pb</span>(b);</span><br><span class="line">        e[b].<span class="built_in">pb</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> dfs=[&amp;](<span class="keyword">auto</span> &amp;&amp; dfs,<span class="type">int</span> x,<span class="type">int</span> c)-&gt;<span class="type">bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        color[x]=c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[x])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//相邻点没有被染色，或已染相同颜色</span></span><br><span class="line">            <span class="keyword">if</span>(!color[ed] &amp;&amp; !<span class="built_in">dfs</span>(dfs,ed,<span class="number">3</span>-c)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(color[ed]==c) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!color[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!<span class="built_in">dfs</span>(dfs,i,<span class="number">1</span>)) no;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    yes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="二分图最大匹配">二分图最大匹配</h3>
<p>设g为二分图，若在g的子图m中，任意两条边都没有公共节点，那么称m为二分图g的一组匹配，在二分图中，包含边数最多的一组匹配称为二分图的最大匹配</p>
<ul>
<li>hall
定理：设G是一个二分图，其顶点集为X和Y，那么存在X到Y的充要条件是在集合X中，任意挑出k个顶点（k可以是
1, 2, …, |X|），那么这些 k 个顶点在集合 Y
中“认识”的（有边连接的）顶点的总数量，必须至少是 k 个。
更通俗地讲：对于任意一个群体的“需求”，满足他们需求的“供给”必须足够。如果对于任何可能的子群体，供给都大于等于需求，那么一个满足所有需求的分配方案就存在。</li>
<li>因为之前匹配的点可能转让给别的点，所以每次遍历点时，都要将vis数组初始化为0</li>
<li>增广路(交错路):路径的起点和终点都是没有匹配的点，且路径经过的边为未匹配，匹配交替出现，这样未匹配的边一定比匹配的边多一条，于是我们修改匹配图将匹配的变为未匹配，未匹配的变为匹配，这样匹配数就比原来多一</li>
<li>算法流程：</li>
<li>1.对于x，如果他喜欢y，且y还没有舞伴，那么x和y配对</li>
<li>2.如果y有舞伴，那么y查看她的舞伴z是否能找的其他舞伴，如果可以就放弃z，和x匹配</li>
<li>时间复杂度<span
class="math inline"><em>O</em>(<em>n</em><em>m</em>)</span></li>
<li>最小点覆盖：二分图的最大匹配数等于这个图的最小点覆盖数(每个点覆盖它的所有边，选择最少的点来覆盖所有的边)</li>
<li>最大独立集：在n个点的二分图中选出m个点使这m个点中两两没有边的m最大，最大独立集=点的个数-最小点覆盖</li>
<li>最小路径覆盖
通俗地讲，就是在一个有向无环图上选出最少的边经过所有的点</li>
</ul>
<ol type="1">
<li>最小不相交路径覆盖 即每条路径经过的顶点各不相同
把原图的一个点v拆成两个点<span
class="math inline"><em>v</em><sub><em>x</em></sub>, <em>v</em><sub><em>y</em></sub></span>，如果存在边<span
class="math inline">(<em>u</em>, <em>v</em>)</span>,则连边<span
class="math inline">(<em>u</em><sub><em>x</em></sub>, <em>v</em><sub><em>y</em></sub>)</span>，这样新图就变成了一张二分图
此时最小路径覆盖=原图的顶点数-新图的最大匹配</li>
<li>最小可相交路径覆盖
先用floyd求传递闭包，如果a到b有路径，那么就连一条<span
class="math inline"><em>a</em> → <em>b</em></span>的边，然后问题就可以转化为最小不相交路径覆盖</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="type">int</span> match[N];<span class="comment">//该点对应的匹配点</span></span><br><span class="line"><span class="type">int</span> vis[N];<span class="comment">//是否访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[ed]) <span class="keyword">continue</span>;</span><br><span class="line">        vis[ed]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(!match[ed] || <span class="built_in">dfs</span>(match[ed]))<span class="comment">//ed未被匹配或者匹配ed的点可以让出ed匹配其他点</span></span><br><span class="line">        &#123;</span><br><span class="line">            match[ed]=u;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n1,n2,m;</span><br><span class="line">    cin&gt;&gt;n1&gt;&gt;n2&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        e[a].<span class="built_in">pb</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);<span class="comment">//每次匹配前清零</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3
id="二分图最大权完美匹配最优匹配">二分图最大权完美匹配(最优匹配)</h3>
<p>给定一张带权的二分图，其左部右部点数相同，均为n个点，若最大匹配有n条边则为完美匹配
二分图边权和最大的完美匹配即二分图最大权完美匹配 #### KM算法</p>
<ul>
<li>可行顶标：给每个节点分配一个顶标<span
class="math inline"><em>l</em><em>a</em>[<em>x</em>], <em>l</em><em>b</em>[<em>y</em>]</span>，对于所有边<span
class="math inline">(<em>x</em>, <em>y</em>)</span>满足<span
class="math inline"><em>l</em><em>a</em>[<em>x</em>] + <em>l</em><em>b</em>[<em>x</em>] ≥ <em>w</em>[<em>x</em>][<em>y</em>]</span></li>
<li>相等子图: 在一组可行顶标下原图的生成子图，包含所有点但只包含<span
class="math inline"><em>l</em><em>a</em>[<em>x</em>] + <em>l</em><em>b</em>[<em>y</em>] = <em>w</em>[<em>x</em>][<em>y</em>]</span>的边</li>
<li>如果相等子图存在完美匹配，即最大权完美匹配</li>
</ul>
<ol type="1">
<li>初始化左边顶标为出边中最大的边权，右边顶标为0</li>
<li>枚举左部点，走交错路找增广路，若能找到一个右侧未匹配点，则找到一条增广路，记录匹配点对；若不能走找到右侧未匹配点则记录<span
class="math inline"><em>d</em><em>e</em><em>l</em><em>t</em><em>a</em> = <em>l</em><em>a</em>[<em>x</em>] + <em>l</em><em>b</em>[<em>y</em>] − <em>w</em>[<em>x</em>][<em>y</em>]</span></li>
<li>根据最小的<span
class="math inline"><em>d</em><em>e</em><em>l</em><em>t</em><em>a</em></span>更新交替路上的顶标值(左减右加)，总能找到新的增广路</li>
</ol>
<h4 id="dfson4">dfs(O(n^4))</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> match[N];</span><br><span class="line"><span class="type">int</span> va[N],vb[N];<span class="comment">//是否在交替路中</span></span><br><span class="line">ll la[N],lb[N];<span class="comment">//左右顶标</span></span><br><span class="line">ll w[N][N],d[N];<span class="comment">//边权和delta值</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    va[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y=<span class="number">1</span>;y&lt;=n;y++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!vb[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(la[x]+lb[y]==w[x][y])<span class="comment">//相等子图，有效边</span></span><br><span class="line">            &#123;</span><br><span class="line">                vb[y]=<span class="number">1</span>;<span class="comment">//匹配y</span></span><br><span class="line">                <span class="keyword">if</span>(!match[y] || <span class="built_in">dfs</span>(match[y]))</span><br><span class="line">                &#123;</span><br><span class="line">                    match[y]=x;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> d[y]=<span class="built_in">min</span>(d[y],la[x]+lb[y]-w[x][y]);<span class="comment">//无效边则记录最小delta</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">km</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) la[i]=-INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) la[i]=<span class="built_in">max</span>(la[i],w[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) lb[i]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">fill</span>(va<span class="number">+1</span>,va<span class="number">+1</span>+n,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">fill</span>(vb<span class="number">+1</span>,vb<span class="number">+1</span>+n,<span class="number">0</span>);</span><br><span class="line">            <span class="built_in">fill</span>(d<span class="number">+1</span>,d+n<span class="number">+1</span>,INF);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">dfs</span>(i)) <span class="keyword">break</span>;</span><br><span class="line">            ll delta=INF;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(!vb[j]) delta=<span class="built_in">min</span>(delta,d[j]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//更新顶标</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(va[j]) la[j]-=delta;</span><br><span class="line">                <span class="keyword">if</span>(vb[j]) lb[j]+=delta;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) res+=w[match[i]][i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) w[i][j]=-INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        w[a][b]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll ans=<span class="built_in">km</span>();</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;match[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="bfson3">bfs(O(n^3))</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">510</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> match[N];</span><br><span class="line"><span class="type">int</span> va[N],vb[N];<span class="comment">//是否在交替路中</span></span><br><span class="line">ll la[N],lb[N];<span class="comment">//左右顶标</span></span><br><span class="line">ll w[N][N];</span><br><span class="line">ll slack[N];<span class="comment">//最小的d</span></span><br><span class="line"><span class="type">int</span> pre[N];<span class="comment">//增广路中右侧节点的匹配节点</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,y=<span class="number">0</span>,yy=<span class="number">0</span>;</span><br><span class="line">    ll delta;</span><br><span class="line">    <span class="built_in">memset</span>(pre,<span class="number">0</span>,<span class="keyword">sizeof</span> pre);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) slack[i]=INF;</span><br><span class="line">    match[y]=u;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=match[y];</span><br><span class="line">        delta=INF;</span><br><span class="line">        vb[y]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vb[i]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(slack[i]&gt;la[x]+lb[i]-w[x][i])</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                slack[i]=la[x]+lb[i]-w[x][i];</span><br><span class="line">                pre[i]=y;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(slack[i]&lt;delta) </span><br><span class="line">            &#123;</span><br><span class="line">                delta=slack[i];</span><br><span class="line">                yy=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(vb[i])</span><br><span class="line">            &#123;</span><br><span class="line">                la[match[i]]-=delta;</span><br><span class="line">                lb[i]+=delta;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> slack[i]-=delta;</span><br><span class="line">        &#125;</span><br><span class="line">        y=yy;</span><br><span class="line">        <span class="keyword">if</span>(match[y]==<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(y) &#123;match[y]=match[pre[y]];y=pre[y];&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">km</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(match,<span class="number">-1</span>,<span class="keyword">sizeof</span> match);</span><br><span class="line">    <span class="built_in">memset</span>(la,<span class="number">0</span>,<span class="keyword">sizeof</span> la);</span><br><span class="line">    <span class="built_in">memset</span>(lb,<span class="number">0</span>,<span class="keyword">sizeof</span> lb);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(vb,<span class="number">0</span>,<span class="keyword">sizeof</span> vb);</span><br><span class="line">        <span class="built_in">bfs</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    ll res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(match[i]!=<span class="number">-1</span>) res+=w[match[i]][i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) w[i][j]=-INF;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        w[a][b]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll ans=<span class="built_in">km</span>();</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;match[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最近公共祖先lca">最近公共祖先lca</h2>
<h3 id="倍增法">倍增法</h3>
<ul>
<li>dep[u]表示结点u的胜读</li>
<li>fa[u][i]表示结点u向上跳<span
class="math inline">2<sup><em>i</em></sup></span>长度的父亲节点</li>
<li>倍增法构建st表的时间复杂度是o(nlogn),单次查询为o(logn)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[<span class="number">2</span>*N];</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">fa</span>(N,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">20</span>));</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">dep</span>(N);</span><br><span class="line"></span><br><span class="line">ll n,m,root;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dep[u]=dep[father]<span class="number">+1</span>;<span class="comment">//更新深度</span></span><br><span class="line">    fa[u][<span class="number">0</span>]=father;<span class="comment">//u节点向上跳一个为其父节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;(<span class="number">1</span>&lt;&lt;i)&lt;=dep[u];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        fa[u][i]=fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];<span class="comment">//倍增思想,分解为两个区间</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ed==father) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(ed,u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dep[u]&lt;dep[v]) <span class="built_in">swap</span>(u,v);<span class="comment">//保证u深度大</span></span><br><span class="line">    <span class="comment">//跳到同一层,两种方法</span></span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">int</span> z=dep[u]-dep[v];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;z;z&gt;&gt;=<span class="number">1</span>,i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(z&amp;<span class="number">1</span>) u=fa[u][i];</span><br><span class="line">        <span class="keyword">if</span>(u==v) <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="comment">// for(int i=19;i&gt;=0;i--)</span></span><br><span class="line">    <span class="comment">// &#123;</span></span><br><span class="line">    <span class="comment">//     if(dep[fa[u][i]]&gt;=dep[v]) u=fa[u][i];//跳的时候保证u点深度不小于v点</span></span><br><span class="line">    <span class="comment">//     if(u==v) return v;//两点重合</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//跳到lca的下一层</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">19</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(fa[u][i]!=fa[v][i])<span class="comment">//保证uv点跳到公共祖先</span></span><br><span class="line">        &#123;</span><br><span class="line">            u=fa[u][i];</span><br><span class="line">            v=fa[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[u][<span class="number">0</span>];<span class="comment">//此时u点位于lca下一层</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;root;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(root,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">lca</span>(u,v)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<p>trips 1. 利用lca判断若干点是否在一条链上
设t1为深度最大点，t2为不与t1在一侧的深度最大点，r为t1与t2的lca，那么对于在链上的点x，其与t1，t2的lca为x和r(或r与x)，否则不在链上，特殊的，若t2不存在，则说明这些点本就在一条链上
1. 求树上两点距离
先处理出所有点到根节点的距离(即深度)，设p为a，b两点的lca，那么a到b的距离为<span
class="math inline"><em>d</em><sub><em>a</em></sub> + <em>d</em><sub><em>b</em></sub> − 2 * <em>d</em><sub><em>p</em></sub></span></p>
<h3 id="树链剖分">树链剖分</h3>
<ul>
<li>重儿子：父节点的所有儿子中子树节点数目最多的儿子</li>
<li>轻儿子：父节点除重儿子以外的儿子</li>
<li>重边：父节点和重儿子连成的边</li>
<li>轻边：父节点和轻儿子连成的边</li>
<li>重链：由多条重边连接而成的路径</li>
</ul>
<ol type="1">
<li>整棵树会被剖分成若干条重链</li>
<li>轻儿子一定是每条重链的顶点</li>
<li>任意一条路径被切分成不超过<span
class="math inline"><em>n</em><em>l</em><em>o</em><em>g</em><em>n</em></span>条链</li>
</ol>
<ul>
<li><span
class="math inline"><em>f</em><em>a</em>[<em>u</em>]</span>：u的父节点</li>
<li><span
class="math inline"><em>d</em><em>e</em><em>p</em>[<em>u</em>]</span>：u的深度</li>
<li><span
class="math inline"><em>s</em><em>o</em><em>n</em>[<em>u</em>]</span>:u的重儿子</li>
<li><span
class="math inline"><em>s</em><em>z</em>[<em>u</em>]</span>:以u为根的子树的结点数</li>
<li><span
class="math inline"><em>t</em><em>o</em><em>p</em>[<em>u</em>]</span>：u所在重链的顶点
算法流程</li>
</ul>
<ol type="1">
<li>第一遍dfs预处理fa,dep,son数组</li>
<li>第二编dfs,预处理top数组</li>
<li>让两个游标沿着各自的重链向上跳，跳到同一条重链上时，深度较小的那个游标所指向的点就是lca`</li>
<li>单次查询为<span
class="math inline"><em>O</em>(<em>l</em><em>o</em><em>g</em><em>n</em>)</span></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">4e4</span><span class="number">+10</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="type">int</span> fa[N];</span><br><span class="line"><span class="type">int</span> dep[N];</span><br><span class="line"><span class="type">int</span> son[N];<span class="comment">//u结点的重儿子</span></span><br><span class="line"><span class="type">int</span> sz[N];<span class="comment">//以u为根的子树的结点数</span></span><br><span class="line"><span class="type">int</span> top[N];<span class="comment">//u所在重链顶点</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> father)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fa[u]=father;</span><br><span class="line">    dep[u]=dep[father]<span class="number">+1</span>;</span><br><span class="line">    sz[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ed==father) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(ed,u);</span><br><span class="line">        sz[u]+=sz[ed];</span><br><span class="line">        <span class="keyword">if</span>(sz[son[u]]&lt;sz[ed]) son[u]=ed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    top[u]=t;</span><br><span class="line">    <span class="keyword">if</span>(!son[u]) <span class="keyword">return</span>;<span class="comment">//无重儿子</span></span><br><span class="line">    <span class="built_in">dfs2</span>(son[u],t);<span class="comment">//搜重儿子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ed==fa[u] || ed==son[u]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs2</span>(ed,ed);<span class="comment">//搜轻儿子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u,<span class="type">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[u]!=top[v])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[u]]&lt;dep[top[v]]) <span class="built_in">swap</span>(u,v);</span><br><span class="line">        u=fa[top[u]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[u]&lt;dep[v] ? u:v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="type">int</span> root=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(b==<span class="number">-1</span>) &#123;root=a;<span class="keyword">continue</span>;&#125;</span><br><span class="line">        e[a].<span class="built_in">pb</span>(b);</span><br><span class="line">        e[b].<span class="built_in">pb</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs1</span>(root,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">dfs2</span>(root,root);</span><br><span class="line">    <span class="type">int</span> q;cin&gt;&gt;q;</span><br><span class="line">    <span class="keyword">while</span>(q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u,v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        cout&lt;&lt;<span class="built_in">lca</span>(u,v)&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="强连通分量">强连通分量</h2>
<h3 id="scc">scc</h3>
<ul>
<li>并查集为双向联通，scc为单向</li>
<li>强联通:一张有向图的节点两两互相可达</li>
<li>强连通分量:极大强连通子图</li>
<li>强连通分量的根:某个强连通分量在搜索树中遇到的第一个节点</li>
<li>O(n+m)</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e4</span><span class="number">+10</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="type">int</span> dfn[N];<span class="comment">//时间戳</span></span><br><span class="line"><span class="type">int</span> low[N];<span class="comment">//回溯值</span></span><br><span class="line"><span class="type">int</span> tot;<span class="comment">//时间戳计数器</span></span><br><span class="line"><span class="type">int</span> stk[N];<span class="comment">//栈</span></span><br><span class="line"><span class="type">int</span> instk[N];<span class="comment">//是否在栈中</span></span><br><span class="line"><span class="type">int</span> top;<span class="comment">//栈计数器</span></span><br><span class="line"><span class="type">int</span> scc[N];<span class="comment">//强连通分量组</span></span><br><span class="line"><span class="type">int</span> siz[N];<span class="comment">//强连通分量大小</span></span><br><span class="line"><span class="type">int</span> cnt;<span class="comment">//强连通分量计数器</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++tot;<span class="comment">//盖戳</span></span><br><span class="line">    stk[++top]=x;<span class="comment">//入栈</span></span><br><span class="line">    instk[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[ed])<span class="comment">//ed尚未访问</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(ed);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[ed]);<span class="comment">//更新回溯值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instk[ed])<span class="comment">//ed已访问且还在栈中,说明x为ed的左子树或祖先节点，即返祖边</span></span><br><span class="line">        &#123;</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],dfn[ed]);<span class="comment">//这里用low更新也可以</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第三种情况为ed已访问且不在栈中，跳过</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dfn[x]==low[x])<span class="comment">//时间戳和回溯值相等说明x为强连通分量根</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            y=stk[top--];instk[y]=<span class="number">0</span>;<span class="comment">//出栈</span></span><br><span class="line">            scc[y]=cnt;<span class="comment">//标记强连通分量组号</span></span><br><span class="line">            ++siz[cnt];<span class="comment">//更新强连通分量大小</span></span><br><span class="line">        &#125;<span class="keyword">while</span>(y!=x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        e[a].<span class="built_in">pb</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);<span class="comment">//可能存在孤立子图，因此要全部搜一遍</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(siz[i]&gt;<span class="number">1</span>) res++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="缩点">缩点</h3>
<ul>
<li><p>所谓缩点就是将每个连通块看成一个点，其性质仍然保留</p></li>
<li><p>左图缩点后为右图</p></li>
<li><p>可发现缩点后的新点的编号是拓扑逆序的(3指向2)，所以若要对新图遍历，要从cnt从大到小枚举</p></li>
<li><p>新增din入度数组与dout出度数组，记录缩点后点的出入度个数</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line"><span class="type">int</span> stk[N],instk[N],top;</span><br><span class="line"><span class="type">int</span> scc[N],siz[N],cnt;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="type">int</span> din[N],dout[N];</span><br><span class="line"><span class="comment">//1.缩点后入度为0的点</span></span><br><span class="line"><span class="comment">//2.入度、出度为0点个数最大值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++tot;</span><br><span class="line">    stk[++top]=x;</span><br><span class="line">    instk[x]=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[ed])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(ed);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[ed]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instk[ed])</span><br><span class="line">        &#123;</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],dfn[ed]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dfn[x]==low[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y;cnt++;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            y=stk[top--];</span><br><span class="line">            instk[y]=<span class="number">0</span>;</span><br><span class="line">            scc[y]=cnt;</span><br><span class="line">            ++siz[cnt];</span><br><span class="line">        &#125;<span class="keyword">while</span>(y!=x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="keyword">while</span>(cin&gt;&gt;x,x)</span><br><span class="line">        &#123;</span><br><span class="line">            e[i].<span class="built_in">pb</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(scc[ed]!=scc[i])<span class="comment">//两点不属于一个强连通分量却有出入度关系</span></span><br><span class="line">            &#123;</span><br><span class="line">                din[scc[ed]]++;<span class="comment">//缩点后的点出入度加加</span></span><br><span class="line">                dout[scc[i]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    a=b=<span class="number">0</span>;<span class="comment">//出入度为0点个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!din[i]) a++;</span><br><span class="line">        <span class="keyword">if</span>(!dout[i]) b++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">if</span>(cnt==<span class="number">1</span>) cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;<span class="comment">//特判一个连通分量</span></span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="built_in">max</span>(a,b)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跑完tarjan之后，先跑出出入度个数，对于两个有关系却不在同一联通块的点，其缩点之后肯定为两个点，且有出入度关系</p>
<h4 id="洛谷p3387">洛谷p3387</h4>
<h5 id="题意-7">题意</h5>
<p>给定一个 <span class="math inline"><em>n</em></span> 个点 <span
class="math inline"><em>m</em></span>
条边有向图，每个点有一个权值，求一条路径，使路径经过的点权值之和最大。你只需要求出这个权值和。</p>
<p>允许多次经过一条边或者一个点，但是，重复经过的点，权值只计算一次。
##### 思路</p>
<p>思路:可以发现每个环(强联通)的权值一定可以全部得到，我们用tarjan缩点后，将每个联通块的点权和赋给新点，在用缩点后的点建新图，然后用dp逆推出最大点权和(由于缩点后新点的编号为拓扑逆序，所以要倒序枚举点编号)
建新图:当两个点有关系却不在同一强连通分量中是 时建边 ###### 代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e4</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line"><span class="type">int</span> stk[N],instk[N],top;</span><br><span class="line"><span class="type">int</span> scc[N],siz[N],cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N],ne[N];</span><br><span class="line"><span class="type">int</span> w[N],nw[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">dp</span>(N);<span class="comment">//以i点为终点的最大点权和</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[x]=dfn[x]=++tot;</span><br><span class="line">    stk[++top]=x;</span><br><span class="line">    instk[x]=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[ed])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(ed);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[ed]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instk[ed])</span><br><span class="line">        &#123;</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],dfn[ed]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(low[x]==dfn[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y;cnt++;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            y=stk[top--];</span><br><span class="line">            instk[y]=<span class="number">0</span>;</span><br><span class="line">            scc[y]=cnt;</span><br><span class="line">            ++siz[cnt];</span><br><span class="line">        &#125;<span class="keyword">while</span>(y!=x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;w[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        e[a].<span class="built_in">pb</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        nw[scc[i]]+=w[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(scc[ed]!=scc[i])<span class="comment">//不在同一连通块</span></span><br><span class="line">            ne[scc[i]].<span class="built_in">pb</span>(scc[ed]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=cnt;i&gt;=<span class="number">1</span>;i--)<span class="comment">//缩点后编号为拓扑逆序，倒枚举</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[i]==<span class="number">0</span>) dp[i]=nw[i];<span class="comment">//为起点时</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ed:ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            dp[ed]=<span class="built_in">max</span>(dp[ed],dp[i]+nw[ed]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">-1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="无向图的连通性">无向图的连通性</h2>
<h3 id="割点">割点</h3>
<ul>
<li>只有无向图中存在割点割边</li>
<li>对于一个无向图，如果将一个点删除之后连通块个数增加（变成两个独立子图）那么该点为割点</li>
<li>割点判定条件</li>
</ul>
<ol type="1">
<li><p>点x不为根结点时，只要满足其存在子节点ed使得low[ed]大于等于dfn[x]，那么x为割点，含义为ed不经过x无法到达比x更先访问的点，所以割去x后必然分裂为两个子图</p></li>
<li><p>点x为根结点时，只要其有两颗以上的子树即可成为割点</p></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> low[N],dfn[N],tot;</span><br><span class="line"><span class="type">int</span> cut[N],root;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"><span class="comment">//割点的两种情况</span></span><br><span class="line"><span class="comment">//1.low[ed]&gt;=dfn[x]</span></span><br><span class="line"><span class="comment">//ed点在不经过x的情况下无法到达比x更早访问的点</span></span><br><span class="line"><span class="comment">//所以割去x点后必然分裂成两个不连通的图</span></span><br><span class="line"><span class="comment">//2.根节点有两颗子树</span></span><br><span class="line"><span class="comment">//显然割去根节点后两颗子树不连通</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++tot;</span><br><span class="line">    <span class="type">int</span> child=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[ed])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(ed);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[ed]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(low[ed]&gt;=dfn[x])<span class="comment">//从ed出发到达不了比x先访问的点</span></span><br><span class="line">            &#123;</span><br><span class="line">                child++;</span><br><span class="line">                <span class="keyword">if</span>(x!=root || child&gt;<span class="number">1</span>) cut[x]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//ed已访问</span></span><br><span class="line">        low[x]=<span class="built_in">min</span>(low[x],dfn[ed]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        e[a].<span class="built_in">pb</span>(b);</span><br><span class="line">        e[b].<span class="built_in">pb</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i])</span><br><span class="line">        &#123;</span><br><span class="line">            root=i;</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cut[i]) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(cut[i]) cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>注意更新low数组时，dfn[y]不可以替换为low[y]，有重边和自环时也不影响</p></li>
<li><p>割点的个数应该在全部点跑完tarjan之后统计，而不是在tarjan函数内统计，这样会导致重复计算</p></li>
<li><p>求a,b之间编号最小的割点</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x]&lt;=dfn[a] &amp;&amp; dfn[x]&gt;dfn[b]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x]&lt;=dfn[b] &amp;&amp; dfn[x]&gt;dfn[a]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++tot;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[ed])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(ed);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[ed]);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(low[ed]&gt;=dfn[x] &amp;&amp; x!=a &amp;&amp; x!=b)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">check</span>(ed)) ans=<span class="built_in">min</span>(ans,x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        low[x]=<span class="built_in">min</span>(low[x],dfn[ed]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="割边">割边</h3>
<ul>
<li>对于一个无向图，如果删掉一条边后图中的连通块个数增加了，那么称该边为桥或者割边</li>
<li>判定条件：若存在x的一个子节点y满足low[y]＞dfn[x]，那么(x，y)就是割边，(和割点的区别就是不能走这条边，又叫反边，而割点可以走，故一个大于一个大于等于)</li>
<li>关于反边的判定：由于我们边编号从0开始，那么0的反边是1，1，反边是0，2的反边是3，3的反边是2，故用异或1来判断是否为反边</li>
</ul>
<h4 id="例题-1">例题</h4>
<p>求所有割边并且按起点小于终点的升序排列</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="type">int</span> h[N];<span class="comment">//以i为起点的第一条边的编号(其实是最后)</span></span><br><span class="line"><span class="type">int</span> idx=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,ne;<span class="comment">//终点，下一条边</span></span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> low[N],dfn[N],tot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bridge</span>&#123;<span class="comment">//割边集</span></span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span> &lt;(<span class="type">const</span> bridge &amp;t)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x!=t.x) <span class="keyword">return</span> x&lt;t.x;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> y&lt;t.y;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;bri[N];</span><br><span class="line"><span class="type">int</span> cnt;<span class="comment">//割边计数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//起点终点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++idx].to=b;</span><br><span class="line">    e[idx].ne=h[a];</span><br><span class="line">    h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> in_edge)</span><span class="comment">//入边</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++tot;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[x];i;i=e[i].ne)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e[i].to;<span class="comment">//终点</span></span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y,i);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;dfn[x])<span class="comment">//x的邻点无法通过其他边到达x，大于是因为不能走反边</span></span><br><span class="line">            &#123;</span><br><span class="line">                bri[cnt++]=&#123;x,y&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i!=(in_edge^<span class="number">1</span>))<span class="comment">//不是反边才能更新</span></span><br><span class="line">        &#123;</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">sort</span>(bri,bri+cnt);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++) cout&lt;&lt;bri[i].x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;bri[i].y&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="边双连通分量">边双连通分量</h3>
<ul>
<li><p>在无向图中，若其不存在割边，则它是一个边双连通图，一个图的极大边双连通子图是他的边双连通分量，即不包含割边的极大连通块</p></li>
<li><p>tarjan求边双连通分量edcc</p></li>
</ul>
<ol type="1">
<li>将所有割边打标记</li>
<li>用一个栈存点，如果遍历完x发现dfn[x]==low[x],说明以x为根节点的子树中还在栈中的节点就是连通块的节点</li>
</ol>
<ul>
<li>edcc缩点</li>
</ul>
<ol type="1">
<li>将所有边双连通分量缩成一个点后，得到一棵树或森林，树边就是原图的割边</li>
</ol>
<ul>
<li>acwing 397冗余路径 答案为边双缩点后(叶子数量+1)/2</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">10010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,ne;<span class="comment">//终点，下一条边</span></span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> idx=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;stk;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dcc[N],cnt;<span class="comment">//边双</span></span><br><span class="line"><span class="type">int</span> bri[M];<span class="comment">//桥</span></span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++idx].to=b;</span><br><span class="line">    e[idx].ne=h[a];</span><br><span class="line">    h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> in_edg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++tot;</span><br><span class="line">    stk.<span class="built_in">push</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[x];i;i=e[i].ne)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y,i);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;dfn[x]) bri[i]=bri[i^<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i!=(in_edg^<span class="number">1</span>)) low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x]==low[x])<span class="comment">//边双的根</span></span><br><span class="line">    &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            dcc[y]=cnt;</span><br><span class="line">            <span class="keyword">if</span>(y==x) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">tarjan</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=idx;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(bri[i])<span class="comment">//割边</span></span><br><span class="line">        &#123;</span><br><span class="line">            d[dcc[e[i].to]]++;<span class="comment">//割边终点所在边双度数+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;cnt&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i]==<span class="number">1</span>) sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;(sum<span class="number">+1</span>)/<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>洛谷p8436</li>
<li>求边双数量以及边双内的点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e7</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,ne;<span class="comment">//终点，下一条边</span></span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> idx=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;stk;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dcc[N],cnt;<span class="comment">//边双</span></span><br><span class="line"><span class="type">int</span> bri[M];<span class="comment">//桥</span></span><br><span class="line"><span class="type">int</span> d[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++idx].to=b;</span><br><span class="line">    e[idx].ne=h[a];</span><br><span class="line">    h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> in_edg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dfn[x]=low[x]=++tot;</span><br><span class="line">    stk.<span class="built_in">push</span>(x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[x];i;i=e[i].ne)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[y])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(y,i);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[y]);</span><br><span class="line">            <span class="keyword">if</span>(low[y]&gt;dfn[x]) bri[i]=bri[i^<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i!=(in_edg^<span class="number">1</span>)) low[x]=<span class="built_in">min</span>(low[x],dfn[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dfn[x]==low[x])<span class="comment">//边双的根</span></span><br><span class="line">    &#123;</span><br><span class="line">        ++cnt;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> y=stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            dcc[y]=cnt;</span><br><span class="line">            <span class="keyword">if</span>(y==x) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="built_in">add</span>(a,b);</span><br><span class="line">        <span class="built_in">add</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    set&lt;<span class="type">int</span>&gt;s[cnt<span class="number">+1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) s[dcc[i]].<span class="built_in">insert</span>(i);</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;s[i].<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:s[i]) cout&lt;&lt;t&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="点双连通分量">点双连通分量</h3>
<ul>
<li>在无向图中，若其不存在割点，则它是一个点双连通图，一个图的极大点双连通子图是他的点双连通分量，即不包含割点的极大连通块</li>
<li>一个割点可能存在于多个点双连通分量中，所以要对割点进行裂点</li>
<li>tarjan算法求点双</li>
</ul>
<ol type="1">
<li>用一个栈存点，若遍历回到x时，发现割点判定<span
class="math inline"><em>l</em><em>o</em><em>w</em>[<em>y</em>] ≥ <em>d</em><em>f</em><em>n</em>[<em>x</em>]</span>成立,则从栈中弹出节点，直到y被弹出</li>
<li>割点x和其他一起构成一个点双vdcc</li>
</ol>
<ul>
<li><p>vdcc缩点
把所有点双连通分量都缩成点，把缩点和对应的割点连边</p></li>
<li><p>洛谷P8435</p></li>
<li><p>求点双个数以及点双内的点</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e5</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> dfn[N],low[N],tot;</span><br><span class="line"><span class="type">int</span> stk[N],top;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;dcc[N];<span class="comment">//点双</span></span><br><span class="line"><span class="type">int</span> cut[N],id[N];</span><br><span class="line"><span class="type">int</span> root,cnt,num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(x==root &amp;&amp; !e[x].<span class="built_in">size</span>())<span class="comment">//孤点</span></span><br><span class="line">    &#123;</span><br><span class="line">        dcc[++cnt].<span class="built_in">pb</span>(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dfn[x]=low[x]=++tot;</span><br><span class="line">    stk[++top]=x;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> child=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[ed])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(ed);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[ed]);</span><br><span class="line">            <span class="keyword">if</span>(low[ed]&gt;=dfn[x])</span><br><span class="line">            &#123;</span><br><span class="line">                child++;</span><br><span class="line">                <span class="keyword">if</span>(x!=root || child&gt;<span class="number">1</span>) cut[x]=<span class="number">1</span>;<span class="comment">//割点</span></span><br><span class="line">                </span><br><span class="line">                cnt++;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="type">int</span> z=stk[top--];</span><br><span class="line">                    dcc[cnt].<span class="built_in">pb</span>(z);</span><br><span class="line">                    <span class="keyword">if</span>(z==ed) <span class="keyword">break</span>;<span class="comment">//x留在栈中</span></span><br><span class="line">                &#125;</span><br><span class="line">                dcc[cnt].<span class="built_in">pb</span>(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">else</span> low[x]=<span class="built_in">min</span>(low[x],dfn[ed]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(a==b) <span class="keyword">continue</span>;<span class="comment">//忽略自环</span></span><br><span class="line">        e[a].<span class="built_in">pb</span>(b);</span><br><span class="line">        e[b].<span class="built_in">pb</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) &#123;root=i;<span class="built_in">tarjan</span>(i);&#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;cnt&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;dcc[i].<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> t:dcc[i]) cout&lt;&lt;t&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floyd求传递闭包">floyd求传递闭包</h2>
<ul>
<li><p>e[i][j]为1表示i对j有关系，利用floyd思想，枚举中间点k，若ij无关系，而ik，kj有关系，则更新ij有关系
### 例题</p></li>
<li><p>设e[i][j]为i比j重，e[0][i]为比i重的数量，e[i][0]为比i轻的数量，跑一遍传递闭包判断比i轻或重的数量是否大于n/2即可</p></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> e[N][N];<span class="comment">//e[i][j]代表i比j重</span></span><br><span class="line"><span class="comment">//e[0][i]代表比i重的总数</span></span><br><span class="line"><span class="comment">//e[i][0]代表比i轻的总数</span></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span><span class="comment">//求传递闭包</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!e[i][j] &amp;&amp; e[i][k] &amp;&amp; e[k][j]) e[i][j]=<span class="number">1</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        e[a][b]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">floyd</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(e[i][j])</span><br><span class="line">            &#123;</span><br><span class="line">                e[<span class="number">0</span>][j]++;</span><br><span class="line">                e[i][<span class="number">0</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e[<span class="number">0</span>][i]&gt;n/<span class="number">2</span> || e[i][<span class="number">0</span>]&gt;n/<span class="number">2</span>) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以用bitset优化，时间复杂度降低到<span class="math inline">$O(
\frac{n^3}{64})$</span></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">110</span>;</span><br><span class="line">bitset&lt;N&gt;st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">            <span class="keyword">if</span>(x) st[i][j]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][k]) st[i]=st[i]|st[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) cout&lt;&lt;st[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floyd-求最小环">floyd 求最小环</h2>
<p>求一张无向图上最少3个点组成的边权之和最小的环的边权和，称为最小环问题
- floyd算法的一个性质为在最外层循环到点k时(尚未开始第k次循环),<span
class="math inline"><em>d</em><sub><em>i</em>, <em>j</em></sub></span>表示从<span
class="math inline"><em>i</em></span>到<span
class="math inline"><em>j</em></span>且仅经过编号<span
class="math inline">1 <em>k</em> − 1</span>的点的最短路。 -
设最小环中编号最大的顶点为<span
class="math inline"><em>k</em></span>，环上与<span
class="math inline"><em>k</em></span>相邻的两个点为<span
class="math inline"><em>i</em>, <em>j</em></span>，则在最外层循环枚举到<span
class="math inline"><em>k</em></span>时，该环的长度<span
class="math inline"><em>a</em><em>n</em><em>s</em> = <em>d</em><sub><em>i</em>, <em>j</em></sub> + <em>w</em><sub><em>j</em>, <em>k</em></sub> + <em>w</em><sub><em>k</em>, <em>i</em></sub></span>
- 故在循环时对于每个<span
class="math inline"><em>k</em></span>枚举满足$i &lt; k <span
class="math inline"><em>且</em></span>j &lt; k<span
class="math inline"><em>的</em><em>点</em><em>对</em></span>(i,j)$取最小值即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    </span><br><span class="line">    vector&lt;vector&lt;ll&gt;&gt;<span class="built_in">w</span>(n<span class="number">+1</span>,<span class="built_in">vector</span>&lt;ll&gt;(n<span class="number">+1</span>,<span class="number">1e9</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) <span class="keyword">if</span>(i==j) w[i][j]=w[j][i]=<span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ll a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        w[a][b]=w[b][a]=c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> dis=w;</span><br><span class="line">    ll ans=<span class="number">1e9</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;k;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans=<span class="built_in">min</span>(ans,dis[i][j]+w[i][k]+w[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[i][j]=<span class="built_in">min</span>(dis[i][j],dis[i][k]+dis[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ans==<span class="number">1e9</span>) cout&lt;&lt;<span class="string">&quot;No solution.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sat">2-sat</h2>
<h3 id="定义">定义</h3>
<p><span
class="math inline">2 − <em>S</em><em>A</em><em>T</em></span>简单的说就是给出<span
class="math inline"><em>n</em></span>个集合,每个集合有两个元素，已知若干个<span
class="math inline">(<em>a</em>, <em>b</em>)</span>，表示<span
class="math inline"><em>a</em></span>与<span
class="math inline"><em>b</em></span>矛盾，然后从每个集合选择一个元素，判断能否一共选<span
class="math inline"><em>n</em></span>个两两不矛盾的元素。
更通俗的讲，有<span
class="math inline"><em>n</em></span>个变量，每种变量只有两种取值(一般为0和1)，还要<span
class="math inline"><em>m</em></span>个关系表达式，一般为<span
class="math inline"><em>x</em><sub>1</sub>&amp;<em>x</em><sub>2</sub> = <em>f</em><em>a</em><em>l</em><em>s</em><em>e</em></span>,询问能否给这<span
class="math inline"><em>n</em></span>个变量找出一组赋值，使得<span
class="math inline"><em>m</em></span>个关系全部满足 ### 逻辑关系</p>
<p><span
class="math inline"><em>a</em> ∨ <em>b</em> ⇔ (¬<em>a</em> → <em>b</em>) ∧ (¬<em>b</em> → <em>a</em>)</span>
- <strong>a成立或b成立</strong>
等价于<strong>若a不成立则b必成立</strong> 或
<strong>若b不成立则a必成立</strong></p>
<h3 id="拆点建图">拆点建图</h3>
<ol type="1">
<li>把每个变量看成点，把n个点拆成2n个点，即把<span
class="math inline"><em>x</em><sub><em>i</em></sub></span>拆成<span
class="math inline"><em>i</em></span>和<span
class="math inline"><em>i</em> + <em>n</em></span>，<span
class="math inline"><em>i</em></span>对应<span
class="math inline"><em>x</em><sub><em>i</em></sub> = 0</span>,<span
class="math inline"><em>i</em> + <em>n</em></span>对应<span
class="math inline"><em>x</em><sub><em>i</em></sub> = 1</span>。</li>
<li>建图就是连有向边，例如<span
class="math inline">(<em>x</em><sub><em>i</em></sub> = <em>a</em>) ∨ (<em>x</em><sub><em>j</em></sub> = <em>b</em>)</span>,其中<span
class="math inline"><em>a</em> = 0/1</span>,<span
class="math inline"><em>b</em> = 0/1</span></li>
</ol>
<ul>
<li>蕴含关系 <span
class="math inline">¬(<em>x</em><sub><em>i</em></sub> = <em>a</em>) → <em>x</em><sub><em>j</em></sub> = <em>b</em></span>可以表示为从<span
class="math inline"><em>i</em> + !<em>a</em> * <em>n</em></span>到<span
class="math inline"><em>j</em> + <em>b</em> * <em>n</em></span>的有向边</li>
<li>蕴含关系 <span
class="math inline">¬(<em>x</em><sub><em>j</em></sub> = <em>b</em>) → <em>x</em><sub><em>i</em></sub> = <em>a</em></span>可以表示为从<span
class="math inline"><em>j</em> + !<em>b</em> * <em>n</em></span>到<span
class="math inline"><em>i</em> + <em>a</em> * <em>n</em></span>的有向边</li>
<li>例如 1 0 2 1建图：<span
class="math inline">1 + <em>n</em> → 2 + <em>n</em></span>,<span
class="math inline">2 → 1</span></li>
<li>即用一边的<span class="math inline">¬</span>推出另一边 ###
tarjan缩点</li>
</ul>
<ol type="1">
<li>跑完tarjan缩点后判断</li>
<li>若<span class="math inline"><em>i</em></span>和<span
class="math inline"><em>i</em> + <em>n</em></span>在同一个<span
class="math inline"><em>s</em><em>c</em><em>c</em></span>里，那么显然无解，因为i不可能即取0又取1</li>
<li>否则<span class="math inline"><em>i</em></span>和<span
class="math inline"><em>i</em> + <em>n</em></span>可能在一条链上或无关，那么一定存在可行解</li>
</ol>
<h3 id="构造可行解">构造可行解</h3>
<ol type="1">
<li>如果有<span
class="math inline"><em>i</em> → <em>i</em> + 1 → ... → <em>i</em> + <em>n</em></span>,那么就选择<span
class="math inline"><em>i</em> + <em>n</em></span>，即令<span
class="math inline"><em>i</em> = 1</span></li>
<li>如果有<span
class="math inline"><em>i</em> + <em>n</em> → <em>i</em> + <em>n</em> − 1 → ... → <em>i</em></span>,那么就选择<span
class="math inline"><em>i</em></span>，即令<span
class="math inline"><em>i</em> = 0</span></li>
</ol>
<ul>
<li>因为蕴含关系具有传递性，选择后者冲突更小</li>
</ul>
<ol start="3" type="1">
<li>tarjan得到的是逆拓扑序，先访问的节点后出栈，后出栈的结点的scc编号更大，根据以上选择原则，得到</li>
</ol>
<ul>
<li>若<span
class="math inline"><em>s</em><em>c</em><em>c</em>[<em>i</em>] &gt; <em>s</em><em>c</em><em>c</em>[<em>i</em> + <em>n</em>]</span>,则令<span
class="math inline"><em>x</em><sub><em>i</em></sub> = 1</span></li>
<li>若<span
class="math inline"><em>s</em><em>c</em><em>c</em>[<em>i</em>] &lt; <em>s</em><em>c</em><em>c</em>[<em>i</em> + <em>n</em>]</span>,则令<span
class="math inline"><em>x</em><sub><em>i</em></sub> = 0</span></li>
</ul>
<h3 id="例题-2">例题</h3>
<h4 id="p4782-模板2-sat">P4782 【模板】2-SAT</h4>
<h5 id="题目描述">题目描述</h5>
<p>有 <span class="math inline"><em>n</em></span> 个布尔变量 <span
class="math inline"><em>x</em><sub>1</sub> ∼ <em>x</em><sub><em>n</em></sub></span>，另有
<span class="math inline"><em>m</em></span>
个需要满足的条件，每个条件的形式都是 「<span
class="math inline"><em>x</em><sub><em>i</em></sub></span> 为
<code>true</code> / <code>false</code> 或 <span
class="math inline"><em>x</em><sub><em>j</em></sub></span> 为
<code>true</code> / <code>false</code>」。比如 「<span
class="math inline"><em>x</em><sub>1</sub></span> 为真或 <span
class="math inline"><em>x</em><sub>3</sub></span> 为假」、「<span
class="math inline"><em>x</em><sub>7</sub></span> 为假或 <span
class="math inline"><em>x</em><sub>2</sub></span> 为假」。</p>
<p>2-SAT 问题的目标是给每个变量赋值使得所有条件得到满足。</p>
<h5 id="输入格式">输入格式</h5>
<p>第一行两个整数 <span class="math inline"><em>n</em></span> 和 <span
class="math inline"><em>m</em></span>，意义如题面所述。</p>
<p>接下来 <span class="math inline"><em>m</em></span> 行每行 <span
class="math inline">4</span> 个整数 <span
class="math inline"><em>i</em></span>, <span
class="math inline"><em>a</em></span>, <span
class="math inline"><em>j</em></span>, <span
class="math inline"><em>b</em></span>，表示 「<span
class="math inline"><em>x</em><sub><em>i</em></sub></span> 为 <span
class="math inline"><em>a</em></span> 或 <span
class="math inline"><em>x</em><sub><em>j</em></sub></span> 为 <span
class="math inline"><em>b</em></span>」(<span
class="math inline"><em>a</em>, <em>b</em> ∈ {0, 1}</span>)</p>
<h5 id="输出格式">输出格式</h5>
<p>如无解，输出 <code>IMPOSSIBLE</code>；否则输出
<code>POSSIBLE</code>。</p>
<p>下一行 <span class="math inline"><em>n</em></span> 个整数 <span
class="math inline"><em>x</em><sub>1</sub> ∼ <em>x</em><sub><em>n</em></sub></span>（<span
class="math inline"><em>x</em><sub><em>i</em></sub> ∈ {0, 1}</span>），表示构造出的解。</p>
<h5 id="输入输出样例-1">输入输出样例 #1</h5>
<h6 id="输入-1">输入 #1</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 1</span><br><span class="line">1 1 3 0</span><br></pre></td></tr></table></figure>
<h6 id="输出-1">输出 #1</h6>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">POSSIBLE</span><br><span class="line">0 0 0</span><br></pre></td></tr></table></figure>
<h5 id="说明提示">说明/提示</h5>
<p><span
class="math inline">1 ≤ <em>n</em>, <em>m</em> ≤ 10<sup>6</sup></span> ,
前 <span class="math inline">3</span> 个点卡小错误，后面 <span
class="math inline">5</span> 个点卡效率。</p>
<p>由于数据随机生成，可能会含有（ 10 0 10
0）之类的坑，但按照最常规写法的写的标程没有出错，各个数据点卡什么的提示在标程里。
### 代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">2e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> low[N],dfn[N],tot;</span><br><span class="line"><span class="type">int</span> stk[N],instk[N],top;</span><br><span class="line"><span class="type">int</span> scc[N],cnt;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;e[N];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    low[x]=dfn[x]=++tot;</span><br><span class="line">    stk[++top]=x;</span><br><span class="line">    instk[x]=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> ed:e[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[ed])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(ed);</span><br><span class="line">            low[x]=<span class="built_in">min</span>(low[x],low[ed]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(instk[ed]) low[x]=<span class="built_in">min</span>(low[x],dfn[ed]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(low[x]==dfn[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y;cnt++;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            y=stk[top--];</span><br><span class="line">            instk[y]=<span class="number">0</span>;</span><br><span class="line">            scc[y]=cnt;</span><br><span class="line">        &#125;<span class="keyword">while</span>(y!=x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=m;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i,a,j,b;</span><br><span class="line">        cin&gt;&gt;i&gt;&gt;a&gt;&gt;j&gt;&gt;b;</span><br><span class="line">        e[i+!a*n].<span class="built_in">pb</span>(j+b*n);</span><br><span class="line">        e[j+!b*n].<span class="built_in">pb</span>(i+a*n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">2</span>*n;i++) <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(scc[i]==scc[i+n]) &#123;cout&lt;&lt;<span class="string">&quot;IMPOSSIBLE&quot;</span>&lt;&lt;endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;POSSIBLE&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cout&lt;&lt;(scc[i]&gt;scc[i+n])&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>),cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="欧拉路欧拉回路">欧拉路、欧拉回路</h2>
<h3 id="定义-1">定义</h3>
<p>欧拉路指再一个途中不重复的经过所有边的通路，如果通路回到了起点则称为欧拉回路</p>
<h3 id="判断方法">判断方法</h3>
<ul>
<li>对于无向图<span class="math inline"><em>G</em></span>,<span
class="math inline"><em>G</em></span>中存在欧拉回路当且仅当<span
class="math inline"><em>G</em></span>中所有度非0的点是连通的且没有奇数度数的点</li>
<li>对于无向图<span class="math inline"><em>G</em></span>,<span
class="math inline"><em>G</em></span>中存在欧拉路当且仅当<span
class="math inline"><em>G</em></span>中所有度非0的点是连通的且<span
class="math inline"><em>G</em></span>恰有0或2个奇数度的点(0个表示存在欧拉回路)</li>
<li>对于有向图<span class="math inline"><em>G</em></span>，<span
class="math inline"><em>G</em></span>中存在欧拉回路当且仅当<span
class="math inline"><em>G</em></span>中所有度非0的点是强连通的且每个点入度出度相同</li>
<li>对于有向图<span class="math inline"><em>G</em></span>，<span
class="math inline"><em>G</em></span>中存在欧拉路当且仅当</li>
</ul>
<ol type="1">
<li>将<span class="math inline"><em>G</em></span>改为无向图之后，<span
class="math inline"><em>G</em></span>中所有度非0的点是连通的</li>
<li>最多只有1个点的出度减入度为1</li>
<li>最多只有1个点的入度减去出度为1</li>
<li>其他所有点的入度等于出度</li>
</ol>
<h3 id="欧拉路">欧拉路</h3>
<ol type="1">
<li>先判断图中是否存在欧拉路(检查度非0的点的连通性以及度数)</li>
<li>找到符合条件的起点x，从x开始dfs，遍历x所有未访问的出边，访问后打上标记(若为无向图则反向边也标记)，回溯时将这条出边加入到答案序列中，dfs结束后，答案序列倒序输出即为欧拉路</li>
<li>时间复杂度<span
class="math inline"><em>O</em>(<em>n</em> + <em>m</em>)</span></li>
</ol>
<h4 id="有向图">有向图</h4>
<h5 id="例1.单词接龙">例1.单词接龙</h5>
<h6 id="题意-8">题意</h6>
<p>给定若干个单词，当单词可以被接龙时当且仅当一个单词的首字母等于另一个单词的尾字母，求是否可以将这些单词全部接龙</p>
<h6 id="思路-7">思路</h6>
<p>将每个单词的首尾字母连边，既可将问题转化为有向图中是否存在欧拉路</p>
<h6 id="代码-7">代码</h6>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;e[<span class="number">27</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">27</span>];<span class="comment">//当前点已经走过几条边</span></span><br><span class="line"><span class="type">int</span> ind[<span class="number">27</span>],outd[<span class="number">27</span>];</span><br><span class="line"><span class="type">int</span> path[<span class="number">100010</span>];<span class="comment">//欧拉路径</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(f[x]&lt;outd[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e[x][f[x]];<span class="comment">//从未走过的边走</span></span><br><span class="line">        ++f[x];</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        path[++cnt]=y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Euler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>,z=<span class="number">0</span>;<span class="comment">//起点，出度比入度大1，出入度不相等</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(outd[i]==ind[i]<span class="number">+1</span>) &#123;y++;x=i;&#125;</span><br><span class="line">        <span class="keyword">if</span>(outd[i]!=ind[i]) z++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!(!z || (y==<span class="number">1</span> &amp;&amp; z==<span class="number">2</span>))) &#123;cout&lt;&lt;<span class="string">&quot;The door cannot be opened.&quot;</span>&lt;&lt;endl;<span class="keyword">return</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!x)<span class="comment">//若不存在奇度点则找不为0的偶数度为起点</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ind[i]) &#123;x=i;<span class="keyword">break</span>;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    <span class="built_in">dfs</span>(x);</span><br><span class="line">    path[++cnt]=x;</span><br><span class="line">    <span class="keyword">if</span>(cnt==n<span class="number">+1</span>) cout&lt;&lt;<span class="string">&quot;Ordering is possible.&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;The door cannot be opened.&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">26</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ind[i]=outd[i]=<span class="number">0</span>;</span><br><span class="line">        e[i].<span class="built_in">clear</span>();</span><br><span class="line">        cnt=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        string s;cin&gt;&gt;s;</span><br><span class="line">        <span class="type">int</span> x=s[<span class="number">0</span>]-<span class="string">&#x27;a&#x27;</span><span class="number">+1</span>;</span><br><span class="line">        <span class="type">int</span> y=s.<span class="built_in">back</span>()-<span class="string">&#x27;a&#x27;</span><span class="number">+1</span>;</span><br><span class="line">        e[x].<span class="built_in">pb</span>(y);</span><br><span class="line">        outd[x]++;</span><br><span class="line">        ind[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Euler</span>();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="无向图">无向图</h4>
<h5 id="例1.判断是否存在欧拉路">例1.判断是否存在欧拉路</h5>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">2e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> y,idx;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">int</span> _y,<span class="type">int</span> _idx)&#123;y=_y,idx=_idx;&#125;</span><br><span class="line">&#125;;<span class="comment">//出边,编号</span></span><br><span class="line">vector&lt;node&gt;e[N];</span><br><span class="line"><span class="type">int</span> n,m,l,cnt=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> f[N];<span class="comment">//当前点走过几条边</span></span><br><span class="line"><span class="type">int</span> d[N];<span class="comment">//度</span></span><br><span class="line"><span class="type">int</span> c[N];<span class="comment">//欧拉路径</span></span><br><span class="line"><span class="type">bool</span> vis[M];<span class="comment">//边是否访问</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(f[x]&lt;d[x])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> y=e[x][f[x]].y;</span><br><span class="line">        <span class="type">int</span> idx=e[x][f[x]].idx;</span><br><span class="line">        <span class="keyword">if</span>(!vis[idx])</span><br><span class="line">        &#123;</span><br><span class="line">            f[x]++;</span><br><span class="line">            vis[idx]=vis[idx^<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(y);</span><br><span class="line">            c[++l]=y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> f[x]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Euler</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">0</span>,y=<span class="number">0</span>;<span class="comment">//起点，奇数度</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(d[i]&amp;<span class="number">1</span>) &#123;y++;x=i;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(y &amp;&amp; y!=<span class="number">2</span>) &#123;no;<span class="keyword">return</span>;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) <span class="keyword">if</span>(d[i]) x=i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(vis,<span class="number">0</span>,<span class="keyword">sizeof</span> vis);</span><br><span class="line">    <span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span> f);</span><br><span class="line">    l=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(x);</span><br><span class="line">    c[++l]=x;</span><br><span class="line">    <span class="keyword">if</span>(l!=m<span class="number">+1</span>) cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        yes;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=l;i&gt;=<span class="number">1</span>;i--) cout&lt;&lt;c[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x,y;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        e[x].<span class="built_in">pb</span>(<span class="built_in">node</span>(y,++cnt));</span><br><span class="line">        e[y].<span class="built_in">pb</span>(<span class="built_in">node</span>(x,++cnt));</span><br><span class="line">        d[x]++;</span><br><span class="line">        d[y]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">Euler</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="网络流">网络流</h2>
<p>网络指一个有向图，有两个特殊节点，源点s和汇点t，每条有向边都有一个权值，称为边的容量，经过每条边的流量不能超过其容量</p>
<h3 id="最大流">最大流</h3>
<ul>
<li>最大流：从源点流向汇点的最大流量</li>
<li>增广路: 一条从源点s到汇点t的所有边容量大于等于0的路径</li>
<li>残留网：由网络中所有节点和剩余容量大于0的边组成的子图，包括有向边和其反边</li>
<li>反边的作用是构建一个退流管道，一旦前面的增广路堵塞了可行流，就通过退流管道退流，实现了反悔操作，实际上等价于重新分配这条边的流量，并不会影响结果</li>
</ul>
<h4 id="ek算法">ek算法</h4>
<p>算法流程： - 每次通过bfs找一条最短路(将原图看作无权图)作为增广路 -
每找到一个增广路就逆序更新残留网并累加可行流 -
mf[i]：源点s到i这条路径上的最小容量 - pre[i]：i的前驱边 -
时间复杂度为<span
class="math inline"><em>O</em>(<em>n</em><em>m</em><sup>2</sup>)</span></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">210</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">5010</span>;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    ll to,w,ne;</span><br><span class="line">&#125;e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> idx=<span class="number">1</span>;</span><br><span class="line">ll mf[N];<span class="comment">//s-i的路径流量上限</span></span><br><span class="line">ll pre[N];<span class="comment">//前驱边</span></span><br><span class="line"><span class="type">int</span> n,m,s,t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++idx].to=b;</span><br><span class="line">    e[idx].w=c;</span><br><span class="line">    e[idx].ne=h[a];</span><br><span class="line">    h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(mf,<span class="number">0</span>,<span class="keyword">sizeof</span> mf);</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    mf[s]=<span class="number">1e9</span>;<span class="comment">//代表源点流量无穷大</span></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)</span><br><span class="line">        &#123;</span><br><span class="line">            ll v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(mf[v]==<span class="number">0</span> &amp;&amp; e[i].w)<span class="comment">//该点没有走过并且边容量不为0</span></span><br><span class="line">            &#123;</span><br><span class="line">                mf[v]=<span class="built_in">min</span>(mf[u],e[i].w);</span><br><span class="line">                pre[v]=i;</span><br><span class="line">                q.<span class="built_in">push</span>(v);</span><br><span class="line">                <span class="keyword">if</span>(v==t) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll flow=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">bfs</span>())<span class="comment">//找增广路</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=t;</span><br><span class="line">        <span class="keyword">while</span>(v!=s)<span class="comment">//更新残留网</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> i=pre[v];</span><br><span class="line">            e[i].w-=mf[t];</span><br><span class="line">            e[i^<span class="number">1</span>].w+=mf[t];</span><br><span class="line">            v=e[i^<span class="number">1</span>].to;</span><br><span class="line">        &#125;</span><br><span class="line">        flow+=mf[t];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">        <span class="built_in">add</span>(b,a,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ll ans=<span class="built_in">EK</span>();</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="dinic算法">dinic算法</h4>
<p>ek算法每次都可能会遍历整张图，但只找到一条增广路，dinic算法通过四个优化可实现每次找到多条增广路
1. 搜索顺序优化 通过bfs建立分层图，每次只走<span
class="math inline"><em>d</em>[<em>v</em>] = <em>d</em>[<em>u</em>] + 1</span>的点，通过dfs回溯就可以实现每次找到多条增广路
2. 当前弧优化
对于一个节点x，当它在dfs中走到第i条弧时，前i-1条弧到汇点的流一定被流满没有可行路线，那么下一次访问x时前i-1条弧就没有意义，所有可以在每次枚举x所连弧时改变起点达到删除前i-1条优化剪枝
3. 剩余流量优化 既边容量用完就剪枝 4. 残枝优化 该点不在增广路上就删除 -
d[u]：深度，即u所在图层 - cur[u]：u的下一条出边，用于弧优化 -
时间复杂度为<span
class="math inline"><em>O</em>(<em>n</em><sup>2</sup><em>m</em>)</span>，大多数情况下点数远小于边数，因此比ek更优</p>
<h3 id="最小割">最小割</h3>
<ul>
<li>割的定义：对于一个网络，切一刀将所有的点划分成S,T两个集合，其中源点s属于集合S，汇点t属于集合T，对于任意一个割都会使网络断流</li>
<li>割的容量：表示所有S到T的边的容量之和</li>
<li>最小割：求一个割使得割的容量最小，最小割的方案往往不唯一</li>
<li>最大流最小割定理：最大流=最小割</li>
<li>任意可行流小于等于任意一个割</li>
<li>最小割划分的求法：
求出最大流之后从源点开始对残留网dfs，标记能够到达的点，被标记的点属于S，未标记的点属于T，此割就是最小割</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="type">void</span> <span class="title">mincut</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vis[u]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v=e[i].to;</span><br><span class="line">        <span class="keyword">if</span>(!vis[v] &amp;&amp; e[i].w) <span class="built_in">mincut</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最小割的最少边数：即S到T的边最少，跑完最大流之后将满流边建正边1，反边0，未满流边正边无穷大，反边0再跑dinic，此时最大流就是最小割的最小边数
证明：是对的，因为第一篇题解的做法和oi-wiki上的区别是未满流的边容量应为∞
正确性在于第一次最小割后我们已经确定了所有割边，此时求最小割边数量时可以看作割去这些边的代价变为1
未满流的边是一定不会被割的，所以设为∞ 然后就变成了第二个最小割问题
注意只有正向边如此改变，反向边重新初始化时容量和流量依然是0，因为反向边一定不是答案中的割边（反向边在实际图中不存在，只是为了算法需要）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">idx=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">0</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(e[i*<span class="number">2</span>].w==<span class="number">0</span>) <span class="comment">//满流边</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(a[i],b[i],<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">add</span>(b[i],a[i],<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">add</span>(a[i],b[i],inf);</span><br><span class="line">        <span class="built_in">add</span>(b[i],a[i],<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ll cnt=<span class="built_in">dinic</span>();</span><br></pre></td></tr></table></figure>
<h3 id="费用流">费用流</h3>
<p>给定一个网络，每条边有容量限制<span
class="math inline"><em>c</em>(<em>u</em>, <em>v</em>)</span>，还有单位流量的费用<span
class="math inline"><em>w</em>(<em>u</em>, <em>v</em>)</span>,即u，v的流量达到<span
class="math inline"><em>f</em>(<em>u</em>, <em>v</em>)</span>时，需要花费<span
class="math inline"><em>f</em>(<em>u</em>, <em>v</em>) * <em>w</em>(<em>u</em>, <em>v</em>)</span>的费用，总花费最小的最大流称为最小费用最大流，总花费最大的最大流称为最大费用最大流，二者合称费用流模型</p>
<p>事实上我们只需要在求解最大流时寻找增广路的bfs算法改为最短路算法，保证每次找到的增广路最短即可
- 为了退流，反向边的初始容量为0，反向边的容量每次+f -
为了退流，反向边的初始费用为-w，走反边的花费为<span
class="math inline">(−<em>w</em>) * <em>f</em></span>
由于反向边很容易出现负边权，因此最短路算法常选择可以处理负边权的spfa，由于spfa无法处理负环，所有图上存在单位费用负环时，需要用消环算法消去负环，或者使用dijstra+势能函数将边权变为非负数</p>
<h4 id="ekspfa">ek+spfa</h4>
<ul>
<li>d[i]: s到i的最短路</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e3</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">5e4</span><span class="number">+10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> to,c,w,ne;</span><br><span class="line">&#125;e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[N];</span><br><span class="line"><span class="type">int</span> idx=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> d[N],mf[N],pre[N],vis[N];</span><br><span class="line">ll flow,cost;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m,s,t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c,<span class="type">int</span> d)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[++idx].to=b;</span><br><span class="line">    e[idx].c=c;</span><br><span class="line">    e[idx].w=d;</span><br><span class="line">    e[idx].ne=h[a];</span><br><span class="line">    h[a]=idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(d,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> d);</span><br><span class="line">    <span class="built_in">memset</span>(mf,<span class="number">0</span>,<span class="keyword">sizeof</span> mf);</span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    d[s]=<span class="number">0</span>;</span><br><span class="line">    mf[s]=inf;</span><br><span class="line">    vis[s]=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[u];i;i=e[i].ne)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> v=e[i].to;</span><br><span class="line">            <span class="type">int</span> c=e[i].c;</span><br><span class="line">            <span class="type">int</span> w=e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(d[u]+w&lt;d[v] &amp;&amp; c)</span><br><span class="line">            &#123;</span><br><span class="line">                d[v]=d[u]+w;</span><br><span class="line">                mf[v]=<span class="built_in">min</span>(mf[u],c);</span><br><span class="line">                pre[v]=i;</span><br><span class="line">                <span class="keyword">if</span>(!vis[v])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    vis[v]=<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mf[t]&gt;<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EK</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">spfa</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v=t;v!=s;)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> i=pre[v];</span><br><span class="line">            e[i].c-=mf[t];</span><br><span class="line">            e[i^<span class="number">1</span>].c+=mf[t];</span><br><span class="line">            v=e[i^<span class="number">1</span>].to;</span><br><span class="line">        &#125;</span><br><span class="line">        flow+=mf[t];</span><br><span class="line">        cost+=mf[t]*d[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c,d;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">        <span class="built_in">add</span>(a,b,c,d);</span><br><span class="line">        <span class="built_in">add</span>(b,a,<span class="number">0</span>,-d);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">EK</span>();</span><br><span class="line">    cout&lt;&lt;flow&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;cost&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://ZcDawn.github.io">ZcDawn</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zcdawn.github.io/ZcDawn/10199fe0.html">https://zcdawn.github.io/ZcDawn/10199fe0.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://ZcDawn.github.io" target="_blank">zc'个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9B%BE%E8%AE%BA/">图论</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E6%9D%BF%E5%AD%90/">板子</a></div><div class="post-share"><div class="social-share" data-image="/image/888.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/ZcDawn/2fae4ad1.html" title="CodeforcesRound 1051 Div2(A-D2)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">CodeforcesRound 1051 Div2(A-D2)</div></div><div class="info-2"><div class="info-item-1">A. All Lengths Subtraction 题面 给定一个长度为n的排列p,对于每个pi都必须选择一个长度为pi的子区间，并且将子区间内的所有元素都减1，询问是否存在一种选择pi的顺序使得该排列p的所有元素都变为0 思路 观察样例可以发现如果一个数x左右两侧的的数都大于x那么一定无解 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define ull unsigned long long #define ll long long#define lc p&lt;&lt;1#define rc p&lt;&lt;1|1#define endl &#x27;\n&#x27;#define all(a) a.begin()+1,a.end()#define all0(a) a.begin(),a.end()#define lowbit(a) (a&amp;-a)#defi...</div></div></div></a><a class="pagination-related" href="/ZcDawn/d87f7e0c.html" title="test"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">test</div></div><div class="info-2"><div class="info-item-1">1cout&lt;&lt;&quot;test&quot;&lt;&lt;endl; </div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/ZcDawn/2fae4ad1.html" title="CodeforcesRound 1051 Div2(A-D2)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-18</div><div class="info-item-2">CodeforcesRound 1051 Div2(A-D2)</div></div><div class="info-2"><div class="info-item-1">A. All Lengths Subtraction 题面 给定一个长度为n的排列p,对于每个pi都必须选择一个长度为pi的子区间，并且将子区间内的所有元素都减1，询问是否存在一种选择pi的顺序使得该排列p的所有元素都变为0 思路 观察样例可以发现如果一个数x左右两侧的的数都大于x那么一定无解 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;bits/stdc++.h&gt;#define ull unsigned long long #define ll long long#define lc p&lt;&lt;1#define rc p&lt;&lt;1|1#define endl &#x27;\n&#x27;#define all(a) a.begin()+1,a.end()#define all0(a) a.begin(),a.end()#define lowbit(a) (a&amp;-a)#defi...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/image/888.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">ZcDawn</div><div class="author-info-description">hello world!</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.</span> <span class="toc-text">图论是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.1.</span> <span class="toc-text">最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dijkstra"><span class="toc-number">1.1.1.</span> <span class="toc-text">Dijkstra</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#floyed"><span class="toc-number">1.1.2.</span> <span class="toc-text">floyed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bellman-ford"><span class="toc-number">1.1.3.</span> <span class="toc-text">bellman-ford</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E5%9B%BE%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.2.</span> <span class="toc-text">分层图最短路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E5%9B%BE%E7%9A%84%E4%B8%80%E8%88%AC%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">分层图的一般模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B1%82%E5%9B%BE%E5%BB%BA%E5%9B%BE%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">分层图建图方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BAk1%E5%B1%82%E5%9B%BE"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">建k + 1层图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B-abc395e"><span class="toc-number">1.2.2.1.1.</span> <span class="toc-text">例 abc395E</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A2%98%E6%84%8F"><span class="toc-number">1.2.2.1.1.1.</span> <span class="toc-text">题意</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-number">1.2.2.1.1.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">1.2.2.1.1.3.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E5%BC%80%E4%B8%80%E7%BB%B4%E8%AE%B0%E5%BD%95%E6%9C%BA%E4%BC%9A%E4%BF%A1%E6%81%AF"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">多开一维记录机会信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-%E6%B4%9B%E8%B0%B7p4568-%E9%A3%9E%E8%A1%8C%E8%B7%AF%E7%BA%BF"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">例题 洛谷P4568 飞行路线</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%98%E6%84%8F-1"><span class="toc-number">1.2.2.3.1.</span> <span class="toc-text">题意</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-1"><span class="toc-number">1.2.2.3.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">1.2.2.3.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-div3-974-e"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">例题 div3 974 E</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%98%E6%84%8F-2"><span class="toc-number">1.2.2.4.1.</span> <span class="toc-text">题意</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-2"><span class="toc-number">1.2.2.4.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-2"><span class="toc-number">1.2.2.4.3.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91%E4%BC%98%E5%8C%96%E5%BB%BA%E5%9B%BE"><span class="toc-number">1.3.</span> <span class="toc-text">线段树优化建图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#trik"><span class="toc-number">1.3.1.</span> <span class="toc-text">trik</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98"><span class="toc-number">1.3.2.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cf786b"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">cf786B</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%98%E6%84%8F-3"><span class="toc-number">1.3.2.1.1.</span> <span class="toc-text">题意</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-3"><span class="toc-number">1.3.2.1.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-3"><span class="toc-number">1.3.2.1.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#p5025%E7%82%B8%E5%BC%B9"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">P5025炸弹</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%98%E6%84%8F-4"><span class="toc-number">1.3.2.2.1.</span> <span class="toc-text">题意</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-4"><span class="toc-number">1.3.2.2.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-4"><span class="toc-number">1.3.2.2.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#p6348-journeys"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">P6348 Journeys</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%98%E6%84%8F-5"><span class="toc-number">1.3.2.3.1.</span> <span class="toc-text">题意</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-5"><span class="toc-number">1.3.2.3.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-5"><span class="toc-number">1.3.2.3.3.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#atcoder-nikkei-programming-contest-2019-2-d---shortest-path-on-a-line"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">atcoder
NIKKEI Programming Contest 2019-2 D - Shortest Path on a Line</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%98%E6%84%8F-6"><span class="toc-number">1.3.2.4.1.</span> <span class="toc-text">题意</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-6"><span class="toc-number">1.3.2.4.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-6"><span class="toc-number">1.3.2.4.3.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#prime"><span class="toc-number">1.5.1.</span> <span class="toc-text">Prime</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%93%B6%E9%A2%88%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.5.2.</span> <span class="toc-text">瓶颈生成树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE"><span class="toc-number">1.6.</span> <span class="toc-text">二分图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D"><span class="toc-number">1.6.1.</span> <span class="toc-text">二分图最大匹配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E6%9D%83%E5%AE%8C%E7%BE%8E%E5%8C%B9%E9%85%8D%E6%9C%80%E4%BC%98%E5%8C%B9%E9%85%8D"><span class="toc-number">1.6.2.</span> <span class="toc-text">二分图最大权完美匹配(最优匹配)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dfson4"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">dfs(O(n^4))</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bfson3"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">bfs(O(n^3))</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88lca"><span class="toc-number">1.7.</span> <span class="toc-text">最近公共祖先lca</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%8D%E5%A2%9E%E6%B3%95"><span class="toc-number">1.7.1.</span> <span class="toc-text">倍增法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86"><span class="toc-number">1.7.2.</span> <span class="toc-text">树链剖分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">1.8.</span> <span class="toc-text">强连通分量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#scc"><span class="toc-number">1.8.1.</span> <span class="toc-text">scc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%A9%E7%82%B9"><span class="toc-number">1.8.2.</span> <span class="toc-text">缩点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%9B%E8%B0%B7p3387"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">洛谷p3387</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%98%E6%84%8F-7"><span class="toc-number">1.8.2.1.1.</span> <span class="toc-text">题意</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="toc-number">1.9.</span> <span class="toc-text">无向图的连通性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%B2%E7%82%B9"><span class="toc-number">1.9.1.</span> <span class="toc-text">割点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%B2%E8%BE%B9"><span class="toc-number">1.9.2.</span> <span class="toc-text">割边</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-1"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">例题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">1.9.3.</span> <span class="toc-text">边双连通分量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%8F%8C%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F"><span class="toc-number">1.9.4.</span> <span class="toc-text">点双连通分量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#floyd%E6%B1%82%E4%BC%A0%E9%80%92%E9%97%AD%E5%8C%85"><span class="toc-number">1.10.</span> <span class="toc-text">floyd求传递闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#floyd-%E6%B1%82%E6%9C%80%E5%B0%8F%E7%8E%AF"><span class="toc-number">1.11.</span> <span class="toc-text">floyd 求最小环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sat"><span class="toc-number">1.12.</span> <span class="toc-text">2-sat</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">1.12.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%86%E7%82%B9%E5%BB%BA%E5%9B%BE"><span class="toc-number">1.12.2.</span> <span class="toc-text">拆点建图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%8F%AF%E8%A1%8C%E8%A7%A3"><span class="toc-number">1.12.3.</span> <span class="toc-text">构造可行解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E9%A2%98-2"><span class="toc-number">1.12.4.</span> <span class="toc-text">例题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#p4782-%E6%A8%A1%E6%9D%BF2-sat"><span class="toc-number">1.12.4.1.</span> <span class="toc-text">P4782 【模板】2-SAT</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.12.4.1.1.</span> <span class="toc-text">题目描述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.12.4.1.2.</span> <span class="toc-text">输入格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.12.4.1.3.</span> <span class="toc-text">输出格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E6%A0%B7%E4%BE%8B-1"><span class="toc-number">1.12.4.1.4.</span> <span class="toc-text">输入输出样例 #1</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-1"><span class="toc-number">1.12.4.1.4.1.</span> <span class="toc-text">输入 #1</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BE%93%E5%87%BA-1"><span class="toc-number">1.12.4.1.4.2.</span> <span class="toc-text">输出 #1</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E%E6%8F%90%E7%A4%BA"><span class="toc-number">1.12.4.1.5.</span> <span class="toc-text">说明&#x2F;提示</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E8%B7%AF%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF"><span class="toc-number">1.13.</span> <span class="toc-text">欧拉路、欧拉回路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-number">1.13.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%96%B9%E6%B3%95"><span class="toc-number">1.13.2.</span> <span class="toc-text">判断方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AC%A7%E6%8B%89%E8%B7%AF"><span class="toc-number">1.13.3.</span> <span class="toc-text">欧拉路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-number">1.13.3.1.</span> <span class="toc-text">有向图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B1.%E5%8D%95%E8%AF%8D%E6%8E%A5%E9%BE%99"><span class="toc-number">1.13.3.1.1.</span> <span class="toc-text">例1.单词接龙</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%A2%98%E6%84%8F-8"><span class="toc-number">1.13.3.1.1.1.</span> <span class="toc-text">题意</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF-7"><span class="toc-number">1.13.3.1.1.2.</span> <span class="toc-text">思路</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-7"><span class="toc-number">1.13.3.1.1.3.</span> <span class="toc-text">代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E5%90%91%E5%9B%BE"><span class="toc-number">1.13.3.2.</span> <span class="toc-text">无向图</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BE%8B1.%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E6%AC%A7%E6%8B%89%E8%B7%AF"><span class="toc-number">1.13.3.2.1.</span> <span class="toc-text">例1.判断是否存在欧拉路</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%B5%81"><span class="toc-number">1.14.</span> <span class="toc-text">网络流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E6%B5%81"><span class="toc-number">1.14.1.</span> <span class="toc-text">最大流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ek%E7%AE%97%E6%B3%95"><span class="toc-number">1.14.1.1.</span> <span class="toc-text">ek算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dinic%E7%AE%97%E6%B3%95"><span class="toc-number">1.14.1.2.</span> <span class="toc-text">dinic算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%89%B2"><span class="toc-number">1.14.2.</span> <span class="toc-text">最小割</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%B9%E7%94%A8%E6%B5%81"><span class="toc-number">1.14.3.</span> <span class="toc-text">费用流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ekspfa"><span class="toc-number">1.14.3.1.</span> <span class="toc-text">ek+spfa</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/ZcDawn/2fae4ad1.html" title="CodeforcesRound 1051 Div2(A-D2)">CodeforcesRound 1051 Div2(A-D2)</a><time datetime="2025-09-18T09:02:26.000Z" title="发表于 2025-09-18 17:02:26">2025-09-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/ZcDawn/10199fe0.html" title="图论是什么">图论是什么</a><time datetime="2025-09-17T14:15:46.000Z" title="发表于 2025-09-17 22:15:46">2025-09-17</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/ZcDawn/d87f7e0c.html" title="test">test</a><time datetime="2025-09-16T09:13:18.000Z" title="发表于 2025-09-16 17:13:18">2025-09-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/ZcDawn/4a17b156.html" title="Hello World">Hello World</a><time datetime="2025-09-12T01:47:50.773Z" title="发表于 2025-09-12 09:47:50">2025-09-12</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By ZcDawn</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async src="https://npm.elemecdn.com/tzy-blog/lib/js/other/sakura.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'bc833ced9747a67cd97891859318d4cf';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.6534116,27.96920845';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu@1.1.6/lib/clock.min.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('flink-list-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('article-sort-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__slideInRight');
    arr[i].setAttribute('data-wow-duration', '1.5s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__flipInY');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script><script async="async">var arr = document.getElementsByClassName('site-card');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__animated');
    arr[i].setAttribute('data-wow-duration', '3s');
    arr[i].setAttribute('data-wow-delay', '');
    arr[i].setAttribute('data-wow-offset', '');
    arr[i].setAttribute('data-wow-iteration', '');
  }</script></div><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow.min.js"></script><script defer src="https://cdn.cbd.int/hexo-butterfly-wowjs/lib/wow_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":200,"height":300,"hOffset":20,"vOffset":-20},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>